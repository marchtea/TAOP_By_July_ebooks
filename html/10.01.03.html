<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title></title><link rel="stylesheet" href="style_cache/github-5da842ffec8a31b5975487ab1278c7ac16876671.css" />
  <link rel="stylesheet" href="style_cache/github2-0a16120e50749ebd0a7bbb45d3c848b65919ec7e.css" />
  <style>
    .file-box {
      margin: 64px auto;
      width: 920px;
    }
	body {
		font-size: 14px;
		line-height: 22px;
		<!--font-family: "adelle",Georgia,"Times New Roman",serif;-->
		color: #4e443c;
		background: #f0efe7;
	}

	.book-toc {

	}
	a {
		color: #0388a6;
		text-decoration: none;
	}
	a:hover {
		color: #04b1d8;
		text-decoration: none;
	}
	ol.book-toc li.chapter{
		margin-bottom:0.6em
	}
	ol.book-toc, ol{
		list-style-type: disc
	}
	ol.book-toc{
		margin:30px 36px
	}
	ol.book-toc a{
		padding-left:4px
	}
	li {
		line-height: 22px;
	}
	h1, h2, h3, h4, h5, h6, li, p, a, ol, div{
		margin: 0;
		padding: 0;
		border: 0;
		vertical-align: baseline;
	}
	ul, ol {
		padding: 0;
		margin: 0 0 11px 25px;
	}
	h1 {
		font-size: 36px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	h2 {
		font-size: 18px;
		color: #f14e32;
		font-weight: bold;
	}
	h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h1{
		font-size: 22px;
		line-height: 44px;
		margin-bottom: 0.4em;
	}
	ol.book-toc h2 {
		font-size: 16px;
		color: #f14e32;
		font-weight: bold;
	}
	ol.book-toc h3, h4, h5, h6 {
		font-size: 14px;
		color: #f14e32;
		font-weight: bold;
	}
	p {
		margin: 0 0 11px;
		font-size: 14px;
		line-height: 22px;
	}
	div {
		display: block;
	}
	div#nav{
		padding: 30px
	}
  </style>
</head>
<body>
  <div class="page">
    <div class="file-box">
	<div class="file">
		<div id="readme" class="blob instapaper_body announce md">
		  <article class="markdown-body entry-content" itemprop="mainContentOfPage">
			<html>
 <body>
  <h1>
   <a class="anchor" href="#%E6%95%99%E4%BD%A0%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0sift%E7%AE%97%E6%B3%95%E4%B8%8B" name="user-content-%E6%95%99%E4%BD%A0%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0sift%E7%AE%97%E6%B3%95%E4%B8%8B">
    <span class="octicon octicon-link">
    </span>
   </a>
   教你一步一步用c语言实现sift算法、下
  </h1>
  <p>
   本文接上，
   <a href="10.01.02.html">
    教你一步一步用c语言实现sift算法、上
   </a>
   而来：
  </p>
  <h3>
   <a class="anchor" href="#%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99" name="user-content-%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    函数编写
   </strong>
  </h3>
  <p>
   ok，接上文，咱们一个一个的来编写main函数中所涉及到所有函数，这也是本文的关键部分：
  </p>
  <div class="highlight highlight-c">
   <pre><span class="c1">//下采样原来的图像，返回缩小2倍尺寸的图像  </span>
<span class="n">CvMat</span> <span class="o">*</span> <span class="nf">halfSizeImage</span><span class="p">(</span><span class="n">CvMat</span> <span class="o">*</span> <span class="n">im</span><span class="p">)</span>   
<span class="p">{</span>  
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">im</span><span class="o">-&gt;</span><span class="n">cols</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">-&gt;</span><span class="n">rows</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>   
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">imnew</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  

<span class="cp">#define Im(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
<span class="cp">#define Imnew(ROW,COL) ((float *)(imnew-&gt;data.fl + imnew-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
            <span class="n">Imnew</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>  
    <span class="k">return</span> <span class="n">imnew</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//上采样原来的图像，返回放大2倍尺寸的图像  </span>
<span class="n">CvMat</span> <span class="o">*</span> <span class="nf">doubleSizeImage</span><span class="p">(</span><span class="n">CvMat</span> <span class="o">*</span> <span class="n">im</span><span class="p">)</span>   
<span class="p">{</span>  
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">im</span><span class="o">-&gt;</span><span class="n">cols</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">-&gt;</span><span class="n">rows</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>   
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">imnew</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  

<span class="cp">#define Im(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
<span class="cp">#define Imnew(ROW,COL) ((float *)(imnew-&gt;data.fl + imnew-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>

    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
            <span class="n">Imnew</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>  

    <span class="k">return</span> <span class="n">imnew</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//上采样原来的图像，返回放大2倍尺寸的线性插值图像  </span>
<span class="n">CvMat</span> <span class="o">*</span> <span class="nf">doubleSizeImage2</span><span class="p">(</span><span class="n">CvMat</span> <span class="o">*</span> <span class="n">im</span><span class="p">)</span>   
<span class="p">{</span>  
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">im</span><span class="o">-&gt;</span><span class="n">cols</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">-&gt;</span><span class="n">rows</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>   
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">imnew</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  

<span class="cp">#define Im(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
<span class="cp">#define Imnew(ROW,COL) ((float *)(imnew-&gt;data.fl + imnew-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>

    <span class="c1">// fill every pixel so we don't have to worry about skipping pixels later  </span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
        <span class="p">{</span>  
            <span class="n">Imnew</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="cm">/* </span>
<span class="cm">    A B C </span>
<span class="cm">    E F G </span>
<span class="cm">    H I J </span>
<span class="cm">    pixels A C H J are pixels from original image </span>
<span class="cm">    pixels B E G I F are interpolated pixels </span>
<span class="cm">    */</span>  
    <span class="c1">// interpolate pixels B and I  </span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>  
            <span class="n">Imnew</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>  
    <span class="c1">// interpolate pixels E and G  </span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>  
            <span class="n">Imnew</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>  
    <span class="c1">// interpolate pixel F  </span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>  
            <span class="n">Imnew</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="mf">0.25</span><span class="o">*</span><span class="p">(</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">Im</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>  
    <span class="k">return</span> <span class="n">imnew</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//双线性插值，返回像素间的灰度值  </span>
<span class="kt">float</span> <span class="nf">getPixelBI</span><span class="p">(</span><span class="n">CvMat</span> <span class="o">*</span> <span class="n">im</span><span class="p">,</span> <span class="kt">float</span> <span class="n">col</span><span class="p">,</span> <span class="kt">float</span> <span class="n">row</span><span class="p">)</span>   
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">irow</span><span class="p">,</span> <span class="n">icol</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">rfrac</span><span class="p">,</span> <span class="n">cfrac</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">row1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">row2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">width</span><span class="o">=</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">height</span><span class="o">=</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span>  
<span class="cp">#define ImMat(ROW,COL) ((float *)(im-&gt;data.fl + im-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>

    <span class="n">irow</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">row</span><span class="p">;</span>  
    <span class="n">icol</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">col</span><span class="p">;</span>  

    <span class="k">if</span> <span class="p">(</span><span class="n">irow</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">irow</span> <span class="o">&gt;=</span> <span class="n">height</span>  
        <span class="o">||</span> <span class="n">icol</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">icol</span> <span class="o">&gt;=</span> <span class="n">width</span><span class="p">)</span>  
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  
        <span class="n">row</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="o">&gt;</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  
        <span class="n">col</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  
    <span class="n">rfrac</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">irow</span><span class="p">);</span>  
    <span class="n">cfrac</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">icol</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">cfrac</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="n">row1</span> <span class="o">=</span> <span class="n">cfrac</span> <span class="o">*</span> <span class="n">ImMat</span><span class="p">(</span><span class="n">irow</span><span class="p">,</span><span class="n">icol</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cfrac</span><span class="p">)</span> <span class="o">*</span> <span class="n">ImMat</span><span class="p">(</span><span class="n">irow</span><span class="p">,</span><span class="n">icol</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>  
    <span class="p">}</span>   
    <span class="k">else</span>   
    <span class="p">{</span>  
        <span class="n">row1</span> <span class="o">=</span> <span class="n">ImMat</span><span class="p">(</span><span class="n">irow</span><span class="p">,</span><span class="n">icol</span><span class="p">);</span>  
    <span class="p">}</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">rfrac</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">cfrac</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>   
        <span class="p">{</span>  
            <span class="n">row2</span> <span class="o">=</span> <span class="n">cfrac</span> <span class="o">*</span> <span class="n">ImMat</span><span class="p">(</span><span class="n">irow</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">icol</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cfrac</span><span class="p">)</span> <span class="o">*</span> <span class="n">ImMat</span><span class="p">(</span><span class="n">irow</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">icol</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>  
        <span class="p">}</span> <span class="k">else</span>   
        <span class="p">{</span>  
            <span class="n">row2</span> <span class="o">=</span> <span class="n">ImMat</span><span class="p">(</span><span class="n">irow</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">icol</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">rfrac</span> <span class="o">*</span> <span class="n">row1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rfrac</span><span class="p">)</span> <span class="o">*</span> <span class="n">row2</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//矩阵归一化  </span>
<span class="kt">void</span> <span class="nf">normalizeMat</span><span class="p">(</span><span class="n">CvMat</span><span class="o">*</span> <span class="n">mat</span><span class="p">)</span>   
<span class="p">{</span>  
<span class="cp">#define Mat(ROW,COL) ((float *)(mat-&gt;data.fl + mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">Mat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>  
    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
            <span class="n">Mat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">/=</span> <span class="n">sum</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//向量归一化  </span>
<span class="kt">void</span> <span class="nf">normalizeVec</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">)</span>   
<span class="p">{</span>  
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">sum</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//得到向量的欧式长度，2-范数  </span>
<span class="kt">float</span> <span class="nf">GetVecNorm</span><span class="p">(</span> <span class="kt">float</span><span class="o">*</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dim</span> <span class="p">)</span>  
<span class="p">{</span>  
    <span class="kt">float</span> <span class="n">sum</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>  
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">dim</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="n">sum</span><span class="o">+=</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>  
<span class="p">}</span>  

<span class="c1">//产生1D高斯核  </span>
<span class="kt">float</span><span class="o">*</span> <span class="nf">GaussianKernel1D</span><span class="p">(</span><span class="kt">float</span> <span class="n">sigma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">)</span>   
<span class="p">{</span>  

    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  
    <span class="c1">//printf("GaussianKernel1D(): Creating 1x%d vector for sigma=%.3f gaussian kernel/n", dim, sigma);  </span>

    <span class="kt">float</span> <span class="o">*</span><span class="n">kern</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span> <span class="n">dim</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">);</span>  
    <span class="kt">float</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">m</span><span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">CV_PI</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">);</span>  
    <span class="kt">double</span> <span class="n">v</span><span class="p">;</span>   
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="n">v</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">s2</span><span class="p">))</span> <span class="p">;</span>  
        <span class="n">kern</span><span class="p">[</span><span class="n">c</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>  
        <span class="n">kern</span><span class="p">[</span><span class="n">c</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="c1">//   normalizeVec(kern, dim);  </span>
    <span class="c1">// for ( i = 0; i &lt; dim; i++)  </span>
    <span class="c1">//  printf("%f  ", kern[i]);  </span>
    <span class="c1">//  printf("/n");  </span>
    <span class="k">return</span> <span class="n">kern</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//产生2D高斯核矩阵  </span>
<span class="n">CvMat</span><span class="o">*</span> <span class="nf">GaussianKernel2D</span><span class="p">(</span><span class="kt">float</span> <span class="n">sigma</span><span class="p">)</span>   
<span class="p">{</span>  
    <span class="c1">// int dim = (int) max(3.0f, GAUSSKERN * sigma);  </span>
    <span class="kt">int</span> <span class="n">dim</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">max</span><span class="p">(</span><span class="mf">3.0f</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">GAUSSKERN</span> <span class="o">*</span><span class="n">sigma</span> <span class="o">+</span> <span class="mf">1.0f</span><span class="p">);</span>  
    <span class="c1">// make dim odd  </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dim</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  
        <span class="n">dim</span><span class="o">++</span><span class="p">;</span>  
    <span class="c1">//printf("GaussianKernel(): Creating %dx%d matrix for sigma=%.3f gaussian/n", dim, dim, sigma);  </span>
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">mat</span><span class="o">=</span><span class="n">cvCreateMat</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
<span class="cp">#define Mat(ROW,COL) ((float *)(mat-&gt;data.fl + mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="kt">float</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>  
    <span class="c1">//printf("%d %d/n", mat.size(), mat[0].size());  </span>
    <span class="kt">float</span> <span class="n">m</span><span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">CV_PI</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">);</span>  
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
        <span class="p">{</span>  
            <span class="c1">//printf("%d %d %d/n", c, i, j);  </span>
            <span class="kt">float</span> <span class="n">v</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">s2</span><span class="p">));</span>  
            <span class="n">Mat</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span><span class="n">v</span><span class="p">;</span>  
            <span class="n">Mat</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span><span class="n">v</span><span class="p">;</span>  
            <span class="n">Mat</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span><span class="n">v</span><span class="p">;</span>  
            <span class="n">Mat</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span><span class="n">v</span><span class="p">;</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="c1">// normalizeMat(mat);  </span>
    <span class="k">return</span> <span class="n">mat</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//x方向像素处作卷积  </span>
<span class="kt">float</span> <span class="nf">ConvolveLocWidth</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">kernel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span> <span class="n">CvMat</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>   
<span class="p">{</span>  
<span class="cp">#define Src(ROW,COL) ((float *)(src-&gt;data.fl + src-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">pixel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">col</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">cen</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>  
    <span class="c1">//printf("ConvolveLoc(): Applying convoluation at location (%d, %d)/n", x, y);  </span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="n">col</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">cen</span><span class="p">);</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">)</span>  
            <span class="n">col</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  
        <span class="n">pixel</span> <span class="o">+=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Src</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">col</span><span class="p">);</span>  
    <span class="p">}</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">pixel</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>  
        <span class="n">pixel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
    <span class="k">return</span> <span class="n">pixel</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//x方向作卷积  </span>
<span class="kt">void</span> <span class="nf">Convolve1DWidth</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">kern</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span> <span class="n">CvMat</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">CvMat</span> <span class="o">*</span> <span class="n">dst</span><span class="p">)</span>   
<span class="p">{</span>  
<span class="cp">#define DST(ROW,COL) ((float *)(dst-&gt;data.fl + dst-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>  

    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
        <span class="p">{</span>  
            <span class="c1">//printf("%d, %d/n", i, j);  </span>
            <span class="n">DST</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">ConvolveLocWidth</span><span class="p">(</span><span class="n">kern</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">}</span>  

<span class="c1">//y方向像素处作卷积  </span>
<span class="kt">float</span> <span class="nf">ConvolveLocHeight</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">kernel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span> <span class="n">CvMat</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>   
<span class="p">{</span>  
<span class="cp">#define Src(ROW,COL) ((float *)(src-&gt;data.fl + src-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">pixel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">cen</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>  
    <span class="c1">//printf("ConvolveLoc(): Applying convoluation at location (%d, %d)/n", x, y);  </span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">cen</span><span class="p">);</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  
            <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">)</span>  
            <span class="n">row</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  
        <span class="n">pixel</span> <span class="o">+=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Src</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>  
    <span class="p">}</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">pixel</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>  
        <span class="n">pixel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
    <span class="k">return</span> <span class="n">pixel</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//y方向作卷积  </span>
<span class="kt">void</span> <span class="nf">Convolve1DHeight</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">kern</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span> <span class="n">CvMat</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">CvMat</span> <span class="o">*</span> <span class="n">dst</span><span class="p">)</span>   
<span class="p">{</span>  
<span class="cp">#define Dst(ROW,COL) ((float *)(dst-&gt;data.fl + dst-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>  
    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
        <span class="p">{</span>  
            <span class="c1">//printf("%d, %d/n", i, j);  </span>
            <span class="n">Dst</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">ConvolveLocHeight</span><span class="p">(</span><span class="n">kern</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">}</span>  

<span class="c1">//卷积模糊图像  </span>
<span class="kt">int</span> <span class="nf">BlurImage</span><span class="p">(</span><span class="n">CvMat</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">CvMat</span> <span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">float</span> <span class="n">sigma</span><span class="p">)</span>   
<span class="p">{</span>  
    <span class="kt">float</span><span class="o">*</span> <span class="n">convkernel</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">dim</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">max</span><span class="p">(</span><span class="mf">3.0f</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">GAUSSKERN</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">+</span> <span class="mf">1.0f</span><span class="p">);</span>  
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">tempMat</span><span class="p">;</span>  
    <span class="c1">// make dim odd  </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dim</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  
        <span class="n">dim</span><span class="o">++</span><span class="p">;</span>  
    <span class="n">tempMat</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
    <span class="n">convkernel</span> <span class="o">=</span> <span class="n">GaussianKernel1D</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>  

    <span class="n">Convolve1DWidth</span><span class="p">(</span><span class="n">convkernel</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">tempMat</span><span class="p">);</span>  
    <span class="n">Convolve1DHeight</span><span class="p">(</span><span class="n">convkernel</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">tempMat</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>  
    <span class="n">cvReleaseMat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tempMat</span><span class="p">);</span>  
    <span class="k">return</span> <span class="n">dim</span><span class="p">;</span>  
<span class="p">}</span> 
</pre>
  </div>
  <h3>
   <a class="anchor" href="#%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4" name="user-content-%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    五个步骤
   </strong>
  </h3>
  <p>
   ok，接下来，进入重点部分，咱们依据上文介绍的sift算法的几个步骤，来一一实现这些函数。
  </p>
  <p>
   为了版述清晰，再贴一下，主函数，顺便再加强下对sift 算法的五个步骤的认识：
  </p>
  <p>
   1、 SIFT算法第一步：图像预处理
  </p>
  <p>
   CvMat *ScaleInitImage(CvMat * im) ;                  //金字塔初始化
  </p>
  <p>
   2、 SIFT算法第二步：建立高斯金字塔函数
  </p>
  <p>
   ImageOctaves* BuildGaussianOctaves(CvMat * image) ;  //建立高斯金字塔
  </p>
  <p>
   3、 SIFT算法第三步：特征点位置检测，最后确定特征点的位置
  </p>
  <p>
   int DetectKeypoint(int numoctaves, ImageOctaves *GaussianPyr);
  </p>
  <p>
   4、 SIFT算法第四步：计算高斯图像的梯度方向和幅值，计算各个特征点的主方向
  </p>
  <p>
   void ComputeGrad_DirecandMag(int numoctaves, ImageOctaves *GaussianPyr);
  </p>
  <p>
   5、 SIFT算法第五步：抽取各个特征点处的特征描述字
  </p>
  <p>
   void ExtractFeatureDescriptors(int numoctaves, ImageOctaves *GaussianPyr);
  </p>
  <p>
   ok，接下来一一具体实现这几个函数：
  </p>
  <h4>
   <a class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E6%AD%A5" name="user-content-sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E6%AD%A5">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第一步
   </strong>
  </h4>
  <p>
   SIFT算法第一步：扩大图像，预滤波剔除噪声，得到金字塔的最底层-第一阶的第一层：
  </p>
  <div class="highlight highlight-c">
   <pre><span class="n">CvMat</span> <span class="o">*</span><span class="nf">ScaleInitImage</span><span class="p">(</span><span class="n">CvMat</span> <span class="o">*</span> <span class="n">im</span><span class="p">)</span>   
<span class="p">{</span>  
    <span class="kt">double</span> <span class="n">sigma</span><span class="p">,</span><span class="n">preblur_sigma</span><span class="p">;</span>  
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">imMat</span><span class="p">;</span>  
    <span class="n">CvMat</span> <span class="o">*</span> <span class="n">dst</span><span class="p">;</span>  
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">tempMat</span><span class="p">;</span>  
    <span class="c1">//首先对图像进行平滑滤波，抑制噪声  </span>
    <span class="n">imMat</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">im</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
    <span class="n">BlurImage</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">imMat</span><span class="p">,</span> <span class="n">INITSIGMA</span><span class="p">);</span>  
    <span class="c1">//针对两种情况分别进行处理：初始化放大原始图像或者在原图像基础上进行后续操作  </span>
    <span class="c1">//建立金字塔的最底层  </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DOUBLE_BASE_IMAGE_SIZE</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="n">tempMat</span> <span class="o">=</span> <span class="n">doubleSizeImage2</span><span class="p">(</span><span class="n">imMat</span><span class="p">);</span><span class="c1">//对扩大两倍的图像进行二次采样，采样率为0.5，采用线性插值  </span>
<span class="cp">#define TEMPMAT(ROW,COL) ((float *)(tempMat-&gt;data.fl + tempMat-&gt;step/sizeof(float) * (ROW)))[(COL)]  </span>

        <span class="n">dst</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
        <span class="n">preblur_sigma</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span><span class="c1">//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span>
        <span class="n">BlurImage</span><span class="p">(</span><span class="n">tempMat</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">preblur_sigma</span><span class="p">);</span>   

        <span class="c1">// The initial blurring for the first image of the first octave of the pyramid.  </span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">INITSIGMA</span><span class="o">*</span><span class="n">INITSIGMA</span><span class="p">)</span> <span class="o">+</span> <span class="n">preblur_sigma</span> <span class="o">*</span> <span class="n">preblur_sigma</span> <span class="p">);</span>  
        <span class="c1">//  sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4);  </span>
        <span class="c1">//printf("Init Sigma: %f/n", sigma);  </span>
        <span class="n">BlurImage</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">tempMat</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>       <span class="c1">//得到金字塔的最底层-放大2倍的图像  </span>
        <span class="n">cvReleaseMat</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">dst</span> <span class="p">);</span>   
        <span class="k">return</span> <span class="n">tempMat</span><span class="p">;</span>  
    <span class="p">}</span>   
    <span class="k">else</span>   
    <span class="p">{</span>  
        <span class="n">dst</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">im</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">im</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
        <span class="c1">//sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA);  </span>
        <span class="n">preblur_sigma</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span><span class="c1">//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">INITSIGMA</span><span class="o">*</span><span class="n">INITSIGMA</span><span class="p">)</span> <span class="o">+</span> <span class="n">preblur_sigma</span> <span class="o">*</span> <span class="n">preblur_sigma</span> <span class="p">);</span>  
        <span class="c1">//printf("Init Sigma: %f/n", sigma);  </span>
        <span class="n">BlurImage</span><span class="p">(</span><span class="n">imMat</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>        <span class="c1">//得到金字塔的最底层：原始图像大小  </span>
        <span class="k">return</span> <span class="n">dst</span><span class="p">;</span>  
    <span class="p">}</span>   
<span class="p">}</span>
</pre>
  </div>
  <h4>
   <a class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AD%A5" name="user-content-sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AD%A5">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第二步
   </strong>
  </h4>
  <p>
   SIFT第二步，建立Gaussian金字塔，给定金字塔第一阶第一层图像后，计算高斯金字塔其他尺度图像，
每一阶的数目由变量SCALESPEROCTAVE决定，给定一个基本图像，计算它的高斯金字塔图像，返回外部向量是阶梯指针，内部向量是每一个阶梯内部的不同尺度图像。
  </p>
  <div class="highlight highlight-c">
   <pre><span class="c1">//SIFT算法第二步  </span>
<span class="n">ImageOctaves</span><span class="o">*</span> <span class="nf">BuildGaussianOctaves</span><span class="p">(</span><span class="n">CvMat</span> <span class="o">*</span> <span class="n">image</span><span class="p">)</span>   
<span class="p">{</span>  
    <span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">octaves</span><span class="p">;</span>  
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">tempMat</span><span class="p">;</span>  
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>  
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>  

    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>  
    <span class="kt">double</span> <span class="n">k</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">SCALESPEROCTAVE</span><span class="p">));</span>  <span class="c1">//方差倍数  </span>
    <span class="kt">float</span> <span class="n">preblur_sigma</span><span class="p">,</span> <span class="n">initial_sigma</span> <span class="p">,</span> <span class="n">sigma1</span><span class="p">,</span><span class="n">sigma2</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">absolute_sigma</span><span class="p">,</span><span class="n">sigma_f</span><span class="p">;</span>  
    <span class="c1">//计算金字塔的阶梯数目  </span>
    <span class="kt">int</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">);</span>  
    <span class="kt">int</span> <span class="n">numoctaves</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">log</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">//金字塔阶数  </span>
    <span class="c1">//限定金字塔的阶梯数  </span>
    <span class="n">numoctaves</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">numoctaves</span><span class="p">,</span> <span class="n">MAXOCTAVES</span><span class="p">);</span>  
    <span class="c1">//为高斯金塔和DOG金字塔分配内存  </span>
    <span class="n">octaves</span><span class="o">=</span><span class="p">(</span><span class="n">ImageOctaves</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">numoctaves</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ImageOctaves</span><span class="p">)</span> <span class="p">);</span>  
    <span class="n">DOGoctaves</span><span class="o">=</span><span class="p">(</span><span class="n">ImageOctaves</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">numoctaves</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ImageOctaves</span><span class="p">)</span> <span class="p">);</span>  

    <span class="n">printf</span><span class="p">(</span><span class="s">"BuildGaussianOctaves(): Base image dimension is %dx%d/n"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">)),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">image</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">))</span> <span class="p">);</span>  
    <span class="n">printf</span><span class="p">(</span><span class="s">"BuildGaussianOctaves(): Building %d octaves/n"</span><span class="p">,</span> <span class="n">numoctaves</span><span class="p">);</span>  

    <span class="c1">// start with initial source image  </span>
    <span class="n">tempMat</span><span class="o">=</span><span class="n">cvCloneMat</span><span class="p">(</span> <span class="n">image</span> <span class="p">);</span>  
    <span class="c1">// preblur_sigma = 1.0;//sqrt(2 - 4*INITSIGMA*INITSIGMA);  </span>
    <span class="n">initial_sigma</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="c1">//sqrt( (4*INITSIGMA*INITSIGMA) + preblur_sigma * preblur_sigma );  </span>
    <span class="c1">//   initial_sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4);  </span>

    <span class="c1">//在每一阶金字塔图像中建立不同的尺度图像  </span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numoctaves</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>     
        <span class="c1">//首先建立金字塔每一阶梯的最底层，其中0阶梯的最底层已经建立好  </span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Building octave %d of dimesion (%d, %d)/n"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span><span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">);</span>  
        <span class="c1">//为各个阶梯分配内存  </span>
        <span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="o">=</span> <span class="p">(</span><span class="n">ImageLevels</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="p">(</span><span class="n">SCALESPEROCTAVE</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ImageLevels</span><span class="p">)</span> <span class="p">);</span>  
        <span class="n">DOGoctaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="o">=</span> <span class="p">(</span><span class="n">ImageLevels</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="p">(</span><span class="n">SCALESPEROCTAVE</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ImageLevels</span><span class="p">)</span> <span class="p">);</span>  
        <span class="c1">//存储各个阶梯的最底层  </span>
        <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">Level</span><span class="o">=</span><span class="n">tempMat</span><span class="p">;</span>  

        <span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="o">=</span><span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span>  
        <span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="o">=</span><span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span>  
        <span class="n">DOGoctaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="o">=</span><span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span>  
        <span class="n">DOGoctaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="o">=</span><span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">DOUBLE_BASE_IMAGE_SIZE</span><span class="p">)</span>  
            <span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subsample</span><span class="o">=</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>  
        <span class="k">else</span>  
            <span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subsample</span><span class="o">=</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>  

        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>       
        <span class="p">{</span>  
            <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">levelsigma</span> <span class="o">=</span> <span class="n">initial_sigma</span><span class="p">;</span>  
            <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">absolute_sigma</span> <span class="o">=</span> <span class="n">initial_sigma</span><span class="p">;</span>  
            <span class="n">printf</span><span class="p">(</span><span class="s">"0 scale and blur sigma : %f /n"</span><span class="p">,</span> <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">subsample</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">octaves</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">absolute_sigma</span><span class="p">));</span>  
        <span class="p">}</span>  
        <span class="k">else</span>  
        <span class="p">{</span>  
            <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">levelsigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">SCALESPEROCTAVE</span><span class="p">].</span><span class="n">levelsigma</span><span class="p">;</span>  
            <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">absolute_sigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">SCALESPEROCTAVE</span><span class="p">].</span><span class="n">absolute_sigma</span><span class="p">;</span>  
            <span class="n">printf</span><span class="p">(</span> <span class="s">"0 scale and blur sigma : %f /n"</span><span class="p">,</span> <span class="p">((</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">absolute_sigma</span><span class="p">)</span> <span class="p">);</span>  
        <span class="p">}</span>  
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">initial_sigma</span><span class="p">;</span>  
        <span class="c1">//建立本阶梯其他层的图像  </span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span>  <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">SCALESPEROCTAVE</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>   
        <span class="p">{</span>  
            <span class="n">dst</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span><span class="c1">//用于存储高斯层  </span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">tempMat</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span><span class="c1">//用于存储DOG层  </span>
            <span class="c1">// 2 passes of 1D on original  </span>
            <span class="c1">//   if(i!=0)  </span>
            <span class="c1">//   {  </span>
            <span class="c1">//       sigma1 = pow(k, j - 1) * ((octaves[i-1].Octave)[j-1].levelsigma);  </span>
            <span class="c1">//          sigma2 = pow(k, j) * ((octaves[i].Octave)[j-1].levelsigma);  </span>
            <span class="c1">//       sigma = sqrt(sigma2*sigma2 - sigma1*sigma1);  </span>
            <span class="n">sigma_f</span><span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="p">;</span>  
            <span class="c1">//   }  </span>
            <span class="c1">//   else  </span>
            <span class="c1">//   {  </span>
            <span class="c1">//       sigma = sqrt(SIGMA * SIGMA - INITSIGMA * INITSIGMA * 4)*pow(k,j);  </span>
            <span class="c1">//   }    </span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">sigma</span><span class="p">;</span>  
            <span class="n">absolute_sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subsample</span><span class="p">);</span>  
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d scale and Blur sigma: %f  /n"</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">absolute_sigma</span><span class="p">);</span>  

            <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">levelsigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">;</span>  
            <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">absolute_sigma</span> <span class="o">=</span> <span class="n">absolute_sigma</span><span class="p">;</span>  
            <span class="c1">//产生高斯层  </span>
            <span class="kt">int</span> <span class="n">length</span><span class="o">=</span><span class="n">BlurImage</span><span class="p">((</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">Level</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">sigma_f</span><span class="p">);</span><span class="c1">//相应尺度  </span>
            <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">levelsigmalength</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>  
            <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">Level</span><span class="o">=</span><span class="n">dst</span><span class="p">;</span>  
            <span class="c1">//产生DOG层  </span>
            <span class="n">cvSub</span><span class="p">(</span> <span class="p">((</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">]).</span><span class="n">Level</span><span class="p">,</span> <span class="p">((</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]).</span><span class="n">Level</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  
            <span class="c1">//         cvAbsDiff( ((octaves[i].Octave)[j]).Level, ((octaves[i].Octave)[j-1]).Level, temp );  </span>
            <span class="p">((</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]).</span><span class="n">Level</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>  
        <span class="p">}</span>  
        <span class="c1">// halve the image size for next iteration  </span>
        <span class="n">tempMat</span>  <span class="o">=</span> <span class="n">halfSizeImage</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">octaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">SCALESPEROCTAVE</span><span class="p">].</span><span class="n">Level</span> <span class="p">)</span> <span class="p">);</span>  
    <span class="p">}</span>  
    <span class="k">return</span> <span class="n">octaves</span><span class="p">;</span>  
<span class="p">}</span>
</pre>
  </div>
  <h4>
   <a class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%89%E6%AD%A5" name="user-content-sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%89%E6%AD%A5">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第三步
   </strong>
  </h4>
  <p>
   SIFT算法第三步，特征点位置检测，最后确定特征点的位置检测DOG金字塔中的局部最大值，找到之后，还要经过两个检验才能确认为特征点：一是它必须有明显的差异，二是他不应该是边缘点，（也就是说，在极值点处的主曲率比应该小于某一个阈值）。
  </p>
  <div class="highlight highlight-c">
   <pre><span class="c1">//SIFT算法第三步，特征点位置检测，  </span>
<span class="kt">int</span> <span class="nf">DetectKeypoint</span><span class="p">(</span><span class="kt">int</span> <span class="n">numoctaves</span><span class="p">,</span> <span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">GaussianPyr</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="c1">//计算用于DOG极值点检测的主曲率比的阈值  </span>
    <span class="kt">double</span> <span class="n">curvature_threshold</span><span class="p">;</span>  
    <span class="n">curvature_threshold</span><span class="o">=</span> <span class="p">((</span><span class="n">CURVATURE_THRESHOLD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">CURVATURE_THRESHOLD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">CURVATURE_THRESHOLD</span><span class="p">;</span>  
<span class="cp">#define ImLevels(OCTAVE,LEVEL,ROW,COL) ((float *)(DOGoctaves[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + DOGoctaves[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>

    <span class="kt">int</span>   <span class="n">keypoint_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numoctaves</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>    
    <span class="p">{</span>          
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">SCALESPEROCTAVE</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="c1">//取中间的scaleperoctave个层  </span>
        <span class="p">{</span>    
            <span class="c1">//在图像的有效区域内寻找具有显著性特征的局部最大值  </span>
            <span class="c1">//float sigma=(GaussianPyr[i].Octave)[j].levelsigma;  </span>
            <span class="c1">//int dim = (int) (max(3.0f, 2.0*GAUSSKERN *sigma + 1.0f)*0.5);  </span>
            <span class="kt">int</span> <span class="n">dim</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">levelsigmalength</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">dim</span><span class="p">;</span><span class="n">m</span><span class="o">&lt;</span><span class="p">((</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">)</span><span class="o">-</span><span class="n">dim</span><span class="p">);</span><span class="n">m</span><span class="o">++</span><span class="p">)</span>   
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">dim</span><span class="p">;</span><span class="n">n</span><span class="o">&lt;</span><span class="p">((</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">)</span><span class="o">-</span><span class="n">dim</span><span class="p">);</span><span class="n">n</span><span class="o">++</span><span class="p">)</span>  
                <span class="p">{</span>       
                    <span class="k">if</span> <span class="p">(</span> <span class="n">fabs</span><span class="p">(</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">&gt;=</span> <span class="n">CONTRAST_THRESHOLD</span> <span class="p">)</span>  
                    <span class="p">{</span>  

                        <span class="k">if</span> <span class="p">(</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">!=</span><span class="mf">0.0</span> <span class="p">)</span>  <span class="c1">//1、首先是非零  </span>
                        <span class="p">{</span>  
                            <span class="kt">float</span> <span class="n">inf_val</span><span class="o">=</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>  
                            <span class="k">if</span><span class="p">((</span> <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>    <span class="c1">//底层的小尺度9  </span>

                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>     <span class="c1">//当前层8  </span>

                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&lt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>     <span class="c1">//下一层大尺度9          </span>
                                <span class="p">)</span> <span class="o">||</span>   
                                <span class="p">(</span> <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  

                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>   

                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span>  <span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span>  <span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&amp;&amp;</span>  
                                <span class="p">(</span><span class="n">inf_val</span> <span class="o">&gt;=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   
                                <span class="p">)</span> <span class="p">)</span>      <span class="c1">//2、满足26个中极值点  </span>
                            <span class="p">{</span>     
                                <span class="c1">//此处可存储  </span>
                                <span class="c1">//然后必须具有明显的显著性，即必须大于CONTRAST_THRESHOLD=0.02  </span>
                                <span class="k">if</span> <span class="p">(</span> <span class="n">fabs</span><span class="p">(</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">&gt;=</span> <span class="n">CONTRAST_THRESHOLD</span> <span class="p">)</span>  
                                <span class="p">{</span>  
                                    <span class="c1">//最后显著处的特征点必须具有足够的曲率比，CURVATURE_THRESHOLD=10.0，首先计算Hessian矩阵  </span>
                                    <span class="c1">// Compute the entries of the Hessian matrix at the extrema location.  </span>
                                    <span class="cm">/* </span>
<span class="cm">                                    1   0   -1 </span>
<span class="cm">                                    0   0   0 </span>
<span class="cm">                                    -1   0   1         *0.25 </span>
<span class="cm">                                    */</span>  
                                    <span class="c1">// Compute the trace and the determinant of the Hessian.  </span>
                                    <span class="c1">//Tr_H = Dxx + Dyy;  </span>
                                    <span class="c1">//Det_H = Dxx*Dyy - Dxy^2;  </span>
                                    <span class="kt">float</span> <span class="n">Dxx</span><span class="p">,</span><span class="n">Dyy</span><span class="p">,</span><span class="n">Dxy</span><span class="p">,</span><span class="n">Tr_H</span><span class="p">,</span><span class="n">Det_H</span><span class="p">,</span><span class="n">curvature_ratio</span><span class="p">;</span>  
                                    <span class="n">Dxx</span> <span class="o">=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>  
                                    <span class="n">Dyy</span> <span class="o">=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>  
                                    <span class="n">Dxy</span> <span class="o">=</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>  
                                    <span class="n">Tr_H</span> <span class="o">=</span> <span class="n">Dxx</span> <span class="o">+</span> <span class="n">Dyy</span><span class="p">;</span>  
                                    <span class="n">Det_H</span> <span class="o">=</span> <span class="n">Dxx</span><span class="o">*</span><span class="n">Dyy</span> <span class="o">-</span> <span class="n">Dxy</span><span class="o">*</span><span class="n">Dxy</span><span class="p">;</span>  
                                    <span class="c1">// Compute the ratio of the principal curvatures.  </span>
                                    <span class="n">curvature_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">Tr_H</span><span class="o">*</span><span class="n">Tr_H</span><span class="p">)</span><span class="o">/</span><span class="n">Det_H</span><span class="p">;</span>  
                                    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">Det_H</span><span class="o">&gt;=</span><span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">curvature_ratio</span> <span class="o">&lt;=</span> <span class="n">curvature_threshold</span><span class="p">)</span> <span class="p">)</span>  <span class="c1">//最后得到最具有显著性特征的特征点  </span>
                                    <span class="p">{</span>  
                                        <span class="c1">//将其存储起来，以计算后面的特征描述字  </span>
                                        <span class="n">keypoint_count</span><span class="o">++</span><span class="p">;</span>  
                                        <span class="n">Keypoint</span> <span class="n">k</span><span class="p">;</span>  
                                        <span class="cm">/* Allocate memory for the keypoint. */</span>  
                                        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">Keypoint</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">KeypointSt</span><span class="p">));</span>  
                                        <span class="n">k</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">;</span>  
                                        <span class="n">keypoints</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>  
                                        <span class="n">k</span><span class="o">-&gt;</span><span class="n">row</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subsample</span><span class="p">);</span>  
                                        <span class="n">k</span><span class="o">-&gt;</span><span class="n">col</span> <span class="o">=</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subsample</span><span class="p">);</span>  
                                        <span class="n">k</span><span class="o">-&gt;</span><span class="n">sy</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>    <span class="c1">//行  </span>
                                        <span class="n">k</span><span class="o">-&gt;</span><span class="n">sx</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">//列  </span>
                                        <span class="n">k</span><span class="o">-&gt;</span><span class="n">octave</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>  
                                        <span class="n">k</span><span class="o">-&gt;</span><span class="n">level</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>  
                                        <span class="n">k</span><span class="o">-&gt;</span><span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">absolute_sigma</span><span class="p">;</span>        
                                    <span class="p">}</span><span class="c1">//if &gt;curvature_thresh  </span>
                                <span class="p">}</span><span class="c1">//if &gt;contrast  </span>
                            <span class="p">}</span><span class="c1">//if inf value  </span>
                        <span class="p">}</span><span class="c1">//if non zero  </span>
                    <span class="p">}</span><span class="c1">//if &gt;contrast  </span>
                <span class="p">}</span>  <span class="c1">//for concrete image level col  </span>
        <span class="p">}</span><span class="c1">//for levels  </span>
    <span class="p">}</span><span class="c1">//for octaves  </span>
    <span class="k">return</span> <span class="n">keypoint_count</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//在图像中，显示SIFT特征点的位置  </span>
<span class="kt">void</span> <span class="nf">DisplayKeypointLocation</span><span class="p">(</span><span class="n">IplImage</span><span class="o">*</span> <span class="n">image</span><span class="p">,</span> <span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">GaussianPyr</span><span class="p">)</span>  
<span class="p">{</span>  

    <span class="n">Keypoint</span> <span class="n">p</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">;</span> <span class="c1">// p指向第一个结点  </span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c1">// 没到表尾  </span>
    <span class="p">{</span>     
        <span class="n">cvLine</span><span class="p">(</span> <span class="n">image</span><span class="p">,</span> <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">col</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">),(</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">)),</span>   
            <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">col</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">),(</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">)),</span> <span class="n">CV_RGB</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>  
            <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  
        <span class="n">cvLine</span><span class="p">(</span> <span class="n">image</span><span class="p">,</span> <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">col</span><span class="p">),(</span><span class="kt">int</span><span class="p">)((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">)),</span>   
            <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">col</span><span class="p">),(</span><span class="kt">int</span><span class="p">)((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">)),</span> <span class="n">CV_RGB</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>  
            <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  
        <span class="c1">//  cvCircle(image,cvPoint((uchar)(p-&gt;col),(uchar)(p-&gt;row)),  </span>
        <span class="c1">//   (int)((GaussianPyr[p-&gt;octave].Octave)[p-&gt;level].absolute_sigma),  </span>
        <span class="c1">//   CV_RGB(255,0,0),1,8,0);  </span>
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  
    <span class="p">}</span>   
<span class="p">}</span>  

<span class="c1">// Compute the gradient direction and magnitude of the gaussian pyramid images  </span>
<span class="kt">void</span> <span class="nf">ComputeGrad_DirecandMag</span><span class="p">(</span><span class="kt">int</span> <span class="n">numoctaves</span><span class="p">,</span> <span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">GaussianPyr</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="c1">// ImageOctaves *mag_thresh ;  </span>
    <span class="n">mag_pyr</span><span class="o">=</span><span class="p">(</span><span class="n">ImageOctaves</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">numoctaves</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ImageOctaves</span><span class="p">)</span> <span class="p">);</span>  
    <span class="n">grad_pyr</span><span class="o">=</span><span class="p">(</span><span class="n">ImageOctaves</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">numoctaves</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ImageOctaves</span><span class="p">)</span> <span class="p">);</span>  
    <span class="c1">// float sigma=( (GaussianPyr[0].Octave)[SCALESPEROCTAVE+2].absolute_sigma ) / GaussianPyr[0].subsample;  </span>
    <span class="c1">// int dim = (int) (max(3.0f, 2 * GAUSSKERN *sigma + 1.0f)*0.5+0.5);  </span>
<span class="cp">#define ImLevels(OCTAVE,LEVEL,ROW,COL) ((float *)(GaussianPyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + GaussianPyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numoctaves</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>    
    <span class="p">{</span>          
        <span class="n">mag_pyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="o">=</span> <span class="p">(</span><span class="n">ImageLevels</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="p">(</span><span class="n">SCALESPEROCTAVE</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ImageLevels</span><span class="p">)</span> <span class="p">);</span>  
        <span class="n">grad_pyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="o">=</span> <span class="p">(</span><span class="n">ImageLevels</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="p">(</span><span class="n">SCALESPEROCTAVE</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ImageLevels</span><span class="p">)</span> <span class="p">);</span>  
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">SCALESPEROCTAVE</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="c1">//取中间的scaleperoctave个层  </span>
        <span class="p">{</span>    
            <span class="n">CvMat</span> <span class="o">*</span><span class="n">Mag</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">,</span> <span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
            <span class="n">CvMat</span> <span class="o">*</span><span class="n">Ori</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">,</span> <span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
            <span class="n">CvMat</span> <span class="o">*</span><span class="n">tempMat1</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">,</span> <span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
            <span class="n">CvMat</span> <span class="o">*</span><span class="n">tempMat2</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">,</span> <span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
            <span class="n">cvZero</span><span class="p">(</span><span class="n">Mag</span><span class="p">);</span>  
            <span class="n">cvZero</span><span class="p">(</span><span class="n">Ori</span><span class="p">);</span>  
            <span class="n">cvZero</span><span class="p">(</span><span class="n">tempMat1</span><span class="p">);</span>  
            <span class="n">cvZero</span><span class="p">(</span><span class="n">tempMat2</span><span class="p">);</span>   
<span class="cp">#define MAG(ROW,COL) ((float *)(Mag-&gt;data.fl + Mag-&gt;step/sizeof(float) *(ROW)))[(COL)]     </span>
<span class="cp">#define ORI(ROW,COL) ((float *)(Ori-&gt;data.fl + Ori-&gt;step/sizeof(float) *(ROW)))[(COL)]    </span>
<span class="cp">#define TEMPMAT1(ROW,COL) ((float *)(tempMat1-&gt;data.fl + tempMat1-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
<span class="cp">#define TEMPMAT2(ROW,COL) ((float *)(tempMat2-&gt;data.fl + tempMat2-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">m</span><span class="o">&lt;</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="n">m</span><span class="o">++</span><span class="p">)</span>   
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">n</span><span class="o">&lt;</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="n">n</span><span class="o">++</span><span class="p">)</span>  
                <span class="p">{</span>  
                    <span class="c1">//计算幅值  </span>
                    <span class="n">TEMPMAT1</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">);</span>  <span class="c1">//dx  </span>
                    <span class="n">TEMPMAT2</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span> <span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="p">);</span>  <span class="c1">//dy  </span>
                    <span class="n">MAG</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">TEMPMAT1</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">TEMPMAT1</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="n">TEMPMAT2</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">TEMPMAT2</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">));</span>  <span class="c1">//mag  </span>
                    <span class="c1">//计算方向  </span>
                    <span class="n">ORI</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span><span class="n">atan</span><span class="p">(</span> <span class="n">TEMPMAT2</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="n">TEMPMAT1</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="p">);</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">ORI</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">==</span><span class="n">CV_PI</span><span class="p">)</span>  
                        <span class="n">ORI</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">=-</span><span class="n">CV_PI</span><span class="p">;</span>  
                <span class="p">}</span>  
                <span class="p">((</span><span class="n">mag_pyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]).</span><span class="n">Level</span><span class="o">=</span><span class="n">Mag</span><span class="p">;</span>  
                <span class="p">((</span><span class="n">grad_pyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]).</span><span class="n">Level</span><span class="o">=</span><span class="n">Ori</span><span class="p">;</span>  
                <span class="n">cvReleaseMat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tempMat1</span><span class="p">);</span>  
                <span class="n">cvReleaseMat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tempMat2</span><span class="p">);</span>  
        <span class="p">}</span><span class="c1">//for levels  </span>
    <span class="p">}</span><span class="c1">//for octaves  </span>
<span class="p">}</span>
</pre>
  </div>
  <h4>
   <a class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E6%AD%A5" name="user-content-sift%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E6%AD%A5">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第四步
   </strong>
  </h4>
  <div class="highlight highlight-c">
   <pre><span class="c1">//SIFT算法第四步：计算各个特征点的主方向，确定主方向  </span>
<span class="kt">void</span> <span class="nf">AssignTheMainOrientation</span><span class="p">(</span><span class="kt">int</span> <span class="n">numoctaves</span><span class="p">,</span> <span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">GaussianPyr</span><span class="p">,</span><span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">mag_pyr</span><span class="p">,</span><span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">grad_pyr</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="c1">// Set up the histogram bin centers for a 36 bin histogram.  </span>
    <span class="kt">int</span> <span class="n">num_bins</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">hist_step</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">PI</span><span class="o">/</span><span class="n">num_bins</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">hist_orient</span><span class="p">[</span><span class="mi">36</span><span class="p">];</span>  
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">36</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="n">hist_orient</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=-</span><span class="n">PI</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="n">hist_step</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">sigma1</span><span class="o">=</span><span class="p">(</span> <span class="p">((</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">SCALESPEROCTAVE</span><span class="p">].</span><span class="n">absolute_sigma</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">subsample</span><span class="p">);</span><span class="c1">//SCALESPEROCTAVE+2  </span>
    <span class="kt">int</span> <span class="n">zero_pad</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">3.0f</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">GAUSSKERN</span> <span class="o">*</span><span class="n">sigma1</span> <span class="o">+</span> <span class="mf">1.0f</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span>  
    <span class="c1">//Assign orientations to the keypoints.  </span>
<span class="cp">#define ImLevels(OCTAVES,LEVELS,ROW,COL) ((float *)((GaussianPyr[(OCTAVES)].Octave[(LEVELS)].Level)-&gt;data.fl + (GaussianPyr[(OCTAVES)].Octave[(LEVELS)].Level)-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>

    <span class="kt">int</span> <span class="n">keypoint_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="n">Keypoint</span> <span class="n">p</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">;</span> <span class="c1">// p指向第一个结点  </span>

    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c1">// 没到表尾  </span>
    <span class="p">{</span>  
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">octave</span><span class="p">;</span>  
        <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>  
        <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sy</span><span class="p">;</span>   <span class="c1">//行  </span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sx</span><span class="p">;</span>   <span class="c1">//列  </span>
        <span class="k">if</span> <span class="p">((</span><span class="n">m</span><span class="o">&gt;=</span><span class="n">zero_pad</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">m</span><span class="o">&lt;</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="o">-</span><span class="n">zero_pad</span><span class="p">)</span><span class="o">&amp;&amp;</span>  
            <span class="p">(</span><span class="n">n</span><span class="o">&gt;=</span><span class="n">zero_pad</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="o">-</span><span class="n">zero_pad</span><span class="p">)</span> <span class="p">)</span>  
        <span class="p">{</span>  
            <span class="kt">float</span> <span class="n">sigma</span><span class="o">=</span><span class="p">(</span> <span class="p">((</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">absolute_sigma</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">subsample</span><span class="p">);</span>  
            <span class="c1">//产生二维高斯模板  </span>
            <span class="n">CvMat</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">GaussianKernel2D</span><span class="p">(</span> <span class="n">sigma</span> <span class="p">);</span>           
            <span class="kt">int</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">mat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">));</span>  
            <span class="c1">//分配用于存储Patch幅值和方向的空间  </span>
<span class="cp">#define MAT(ROW,COL) ((float *)(mat-&gt;data.fl + mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>

            <span class="c1">//声明方向直方图变量  </span>
            <span class="kt">double</span><span class="o">*</span> <span class="n">orienthist</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">36</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>  
            <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">sw</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">sw</span> <span class="o">&lt;</span> <span class="mi">36</span> <span class="p">;</span> <span class="o">++</span><span class="n">sw</span><span class="p">)</span>   
            <span class="p">{</span>  
                <span class="n">orienthist</span><span class="p">[</span><span class="n">sw</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>    
            <span class="p">}</span>  
            <span class="c1">//在特征点的周围统计梯度方向  </span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="n">dim</span><span class="p">,</span><span class="n">mm</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">x</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">dim</span><span class="p">);</span><span class="n">x</span><span class="o">++</span><span class="p">,</span><span class="n">mm</span><span class="o">++</span><span class="p">)</span>   
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="n">dim</span><span class="p">,</span><span class="n">nn</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">y</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">dim</span><span class="p">);</span><span class="n">y</span><span class="o">++</span><span class="p">,</span><span class="n">nn</span><span class="o">++</span><span class="p">)</span>  
                <span class="p">{</span>       
                    <span class="c1">//计算特征点处的幅值  </span>
                    <span class="kt">double</span> <span class="n">dx</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>  <span class="c1">//dx  </span>
                    <span class="kt">double</span> <span class="n">dy</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">-</span><span class="n">ImLevels</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">));</span>  <span class="c1">//dy  </span>
                    <span class="kt">double</span> <span class="n">mag</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span><span class="o">+</span><span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">);</span>  <span class="c1">//mag  </span>
                    <span class="c1">//计算方向  </span>
                    <span class="kt">double</span> <span class="n">Ori</span> <span class="o">=</span><span class="n">atan</span><span class="p">(</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">dy</span><span class="o">/</span><span class="n">dx</span> <span class="p">);</span>  
                    <span class="kt">int</span> <span class="n">binIdx</span> <span class="o">=</span> <span class="n">FindClosestRotationBin</span><span class="p">(</span><span class="mi">36</span><span class="p">,</span> <span class="n">Ori</span><span class="p">);</span>                   <span class="c1">//得到离现有方向最近的直方块  </span>
                    <span class="n">orienthist</span><span class="p">[</span><span class="n">binIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">orienthist</span><span class="p">[</span><span class="n">binIdx</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">*</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">MAT</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span><span class="n">nn</span><span class="p">);</span><span class="c1">//利用高斯加权累加进直方图相应的块  </span>
                <span class="p">}</span>  
                <span class="c1">// Find peaks in the orientation histogram using nonmax suppression.  </span>
                <span class="n">AverageWeakBins</span> <span class="p">(</span><span class="n">orienthist</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>  
                <span class="c1">// find the maximum peak in gradient orientation  </span>
                <span class="kt">double</span> <span class="n">maxGrad</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>  
                <span class="kt">int</span> <span class="n">maxBin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">36</span> <span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span>   
                <span class="p">{</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">orienthist</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxGrad</span><span class="p">)</span>   
                    <span class="p">{</span>  
                        <span class="n">maxGrad</span> <span class="o">=</span> <span class="n">orienthist</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>  
                        <span class="n">maxBin</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>  
                    <span class="p">}</span>  
                <span class="p">}</span>  
                <span class="c1">// First determine the real interpolated peak high at the maximum bin  </span>
                <span class="c1">// position, which is guaranteed to be an absolute peak.  </span>
                <span class="kt">double</span> <span class="n">maxPeakValue</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>  
                <span class="kt">double</span> <span class="n">maxDegreeCorrection</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>  
                <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">InterpolateOrientation</span> <span class="p">(</span> <span class="n">orienthist</span><span class="p">[</span><span class="n">maxBin</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">(</span><span class="mi">36</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">maxBin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)],</span>  
                    <span class="n">orienthist</span><span class="p">[</span><span class="n">maxBin</span><span class="p">],</span> <span class="n">orienthist</span><span class="p">[(</span><span class="n">maxBin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">36</span><span class="p">],</span>  
                    <span class="o">&amp;</span><span class="n">maxDegreeCorrection</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maxPeakValue</span><span class="p">))</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>  
                    <span class="n">printf</span><span class="p">(</span><span class="s">"BUG: Parabola fitting broken"</span><span class="p">);</span>  

                <span class="c1">// Now that we know the maximum peak value, we can find other keypoint  </span>
                <span class="c1">// orientations, which have to fulfill two criterias:  </span>
                <span class="c1">//  </span>
                <span class="c1">//  1. They must be a local peak themselves. Else we might add a very  </span>
                <span class="c1">//     similar keypoint orientation twice (imagine for example the  </span>
                <span class="c1">//     values: 0.4 1.0 0.8, if 1.0 is maximum peak, 0.8 is still added  </span>
                <span class="c1">//     with the default threshhold, but the maximum peak orientation  </span>
                <span class="c1">//     was already added).  </span>
                <span class="c1">//  2. They must have at least peakRelThresh times the maximum peak  </span>
                <span class="c1">//     value.  </span>
                <span class="kt">bool</span> <span class="n">binIsKeypoint</span><span class="p">[</span><span class="mi">36</span><span class="p">];</span>  
                <span class="k">for</span> <span class="p">(</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">36</span> <span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span>   
                <span class="p">{</span>  
                    <span class="n">binIsKeypoint</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  
                    <span class="c1">// The maximum peak of course is  </span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">maxBin</span><span class="p">)</span>   
                    <span class="p">{</span>  
                        <span class="n">binIsKeypoint</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  
                        <span class="k">continue</span><span class="p">;</span>  
                    <span class="p">}</span>  
                    <span class="c1">// Local peaks are, too, in case they fulfill the threshhold  </span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">orienthist</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">peakRelThresh</span> <span class="o">*</span> <span class="n">maxPeakValue</span><span class="p">))</span>  
                        <span class="k">continue</span><span class="p">;</span>  
                    <span class="kt">int</span> <span class="n">leftI</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mi">36</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  
                    <span class="kt">int</span> <span class="n">rightI</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">36</span><span class="p">;</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">orienthist</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">orienthist</span><span class="p">[</span><span class="n">leftI</span><span class="p">]</span> <span class="o">||</span> <span class="n">orienthist</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">orienthist</span><span class="p">[</span><span class="n">rightI</span><span class="p">])</span>  
                        <span class="k">continue</span><span class="p">;</span> <span class="c1">// no local peak  </span>
                    <span class="n">binIsKeypoint</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  
                <span class="p">}</span>  
                <span class="c1">// find other possible locations  </span>
                <span class="kt">double</span> <span class="n">oneBinRad</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">PI</span><span class="p">)</span> <span class="o">/</span> <span class="mi">36</span><span class="p">;</span>  
                <span class="k">for</span> <span class="p">(</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">36</span> <span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span>   
                <span class="p">{</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">binIsKeypoint</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>  
                        <span class="k">continue</span><span class="p">;</span>  
                    <span class="kt">int</span> <span class="n">bLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mi">36</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  
                    <span class="kt">int</span> <span class="n">bRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">36</span><span class="p">;</span>  
                    <span class="c1">// Get an interpolated peak direction and value guess.  </span>
                    <span class="kt">double</span> <span class="n">peakValue</span><span class="p">;</span>  
                    <span class="kt">double</span> <span class="n">degreeCorrection</span><span class="p">;</span>  

                    <span class="kt">double</span> <span class="n">maxPeakValue</span><span class="p">,</span> <span class="n">maxDegreeCorrection</span><span class="p">;</span>                
                    <span class="k">if</span> <span class="p">(</span><span class="n">InterpolateOrientation</span> <span class="p">(</span> <span class="n">orienthist</span><span class="p">[</span><span class="n">maxBin</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">(</span><span class="mi">36</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">maxBin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)],</span>  
                        <span class="n">orienthist</span><span class="p">[</span><span class="n">maxBin</span><span class="p">],</span> <span class="n">orienthist</span><span class="p">[(</span><span class="n">maxBin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">36</span><span class="p">],</span>  
                        <span class="err">°</span><span class="n">reeCorrection</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peakValue</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>  
                    <span class="p">{</span>  
                        <span class="n">printf</span><span class="p">(</span><span class="s">"BUG: Parabola fitting broken"</span><span class="p">);</span>  
                    <span class="p">}</span>  

                    <span class="kt">double</span> <span class="n">degree</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">degreeCorrection</span><span class="p">)</span> <span class="o">*</span> <span class="n">oneBinRad</span> <span class="o">-</span> <span class="n">PI</span><span class="p">;</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">degree</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">PI</span><span class="p">)</span>  
                        <span class="n">degree</span> <span class="o">+=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">PI</span><span class="p">;</span>  
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">degree</span> <span class="o">&gt;</span> <span class="n">PI</span><span class="p">)</span>  
                        <span class="n">degree</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">PI</span><span class="p">;</span>  
                    <span class="c1">//存储方向，可以直接利用检测到的链表进行该步主方向的指定;  </span>
                    <span class="c1">//分配内存重新存储特征点  </span>
                    <span class="n">Keypoint</span> <span class="n">k</span><span class="p">;</span>  
                    <span class="cm">/* Allocate memory for the keypoint Descriptor. */</span>  
                    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">Keypoint</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">KeypointSt</span><span class="p">));</span>  
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">keyDescriptors</span><span class="p">;</span>  
                    <span class="n">keyDescriptors</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>  
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">descrip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">LEN</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">row</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">;</span>  
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">col</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">col</span><span class="p">;</span>  
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">sy</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sy</span><span class="p">;</span>    <span class="c1">//行  </span>
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">sx</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sx</span><span class="p">;</span>    <span class="c1">//列  </span>
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">octave</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">octave</span><span class="p">;</span>  
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>  
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">scale</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">scale</span><span class="p">;</span>        
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">ori</span> <span class="o">=</span> <span class="n">degree</span><span class="p">;</span>  
                    <span class="n">k</span><span class="o">-&gt;</span><span class="n">mag</span> <span class="o">=</span> <span class="n">peakValue</span><span class="p">;</span>    
                <span class="p">}</span><span class="c1">//for  </span>
                <span class="n">free</span><span class="p">(</span><span class="n">orienthist</span><span class="p">);</span>  
        <span class="p">}</span>  
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  
    <span class="p">}</span>   
<span class="p">}</span>  

<span class="c1">//寻找与方向直方图最近的柱，确定其index   </span>
<span class="kt">int</span> <span class="nf">FindClosestRotationBin</span> <span class="p">(</span><span class="kt">int</span> <span class="n">binCount</span><span class="p">,</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">angle</span> <span class="o">+=</span> <span class="n">CV_PI</span><span class="p">;</span>  
    <span class="n">angle</span> <span class="o">/=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">CV_PI</span><span class="p">;</span>  
    <span class="c1">// calculate the aligned bin  </span>
    <span class="n">angle</span> <span class="o">*=</span> <span class="n">binCount</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">angle</span><span class="p">;</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">binCount</span><span class="p">)</span>  
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="k">return</span> <span class="p">(</span><span class="n">idx</span><span class="p">);</span>  
<span class="p">}</span>  

<span class="c1">// Average the content of the direction bins.  </span>
<span class="kt">void</span> <span class="nf">AverageWeakBins</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">hist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">binCount</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="c1">// TODO: make some tests what number of passes is the best. (its clear  </span>
    <span class="c1">// one is not enough, as we may have something like  </span>
    <span class="c1">// ( 0.4, 0.4, 0.3, 0.4, 0.4 ))  </span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sn</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">sn</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">;</span> <span class="o">++</span><span class="n">sn</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="kt">double</span> <span class="n">firstE</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
        <span class="kt">double</span> <span class="n">last</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="n">binCount</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>  
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sw</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">sw</span> <span class="o">&lt;</span> <span class="n">binCount</span> <span class="p">;</span> <span class="o">++</span><span class="n">sw</span><span class="p">)</span>   
        <span class="p">{</span>  
            <span class="kt">double</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="n">sw</span><span class="p">];</span>  
            <span class="kt">double</span> <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">==</span> <span class="p">(</span><span class="n">binCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">?</span> <span class="n">firstE</span> <span class="o">:</span> <span class="n">hist</span><span class="p">[(</span><span class="n">sw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">binCount</span><span class="p">];</span>  
            <span class="n">hist</span><span class="p">[</span><span class="n">sw</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">last</span> <span class="o">+</span> <span class="n">cur</span> <span class="o">+</span> <span class="n">next</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">;</span>  
            <span class="n">last</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">}</span>  

<span class="c1">// Fit a parabol to the three points (-1.0 ; left), (0.0 ; middle) and  </span>
<span class="c1">// (1.0 ; right).  </span>
<span class="c1">// Formulas:  </span>
<span class="c1">// f(x) = a (x - c)^2 + b  </span>
<span class="c1">// c is the peak offset (where f'(x) is zero), b is the peak value.  </span>
<span class="c1">// In case there is an error false is returned, otherwise a correction  </span>
<span class="c1">// value between [-1 ; 1] is returned in 'degreeCorrection', where -1  </span>
<span class="c1">// means the peak is located completely at the left vector, and -0.5 just  </span>
<span class="c1">// in the middle between left and middle and &gt; 0 to the right side. In  </span>
<span class="c1">// 'peakValue' the maximum estimated peak value is stored.  </span>
<span class="kt">bool</span> <span class="nf">InterpolateOrientation</span> <span class="p">(</span><span class="kt">double</span> <span class="n">left</span><span class="p">,</span> <span class="kt">double</span> <span class="n">middle</span><span class="p">,</span><span class="kt">double</span> <span class="n">right</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">degreeCorrection</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">peakValue</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">middle</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>   <span class="c1">//抛物线捏合系数a  </span>
    <span class="c1">// degreeCorrection = peakValue = Double.NaN;  </span>

    <span class="c1">// Not a parabol  </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>  
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  
    <span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(((</span><span class="n">left</span> <span class="o">-</span> <span class="n">middle</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>  
    <span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span>  
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  
    <span class="o">*</span><span class="n">degreeCorrection</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>  
    <span class="o">*</span><span class="n">peakValue</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>  
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//显示特征点处的主方向  </span>
<span class="kt">void</span> <span class="nf">DisplayOrientation</span> <span class="p">(</span><span class="n">IplImage</span><span class="o">*</span> <span class="n">image</span><span class="p">,</span> <span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">GaussianPyr</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">Keypoint</span> <span class="n">p</span> <span class="o">=</span> <span class="n">keyDescriptors</span><span class="p">;</span> <span class="c1">// p指向第一个结点  </span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c1">// 没到表尾  </span>
    <span class="p">{</span>  
        <span class="kt">float</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">octave</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">absolute_sigma</span><span class="p">;</span>  
        <span class="kt">float</span> <span class="n">autoscale</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>   
        <span class="kt">float</span> <span class="n">uu</span><span class="o">=</span><span class="n">autoscale</span><span class="o">*</span><span class="n">scale</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ori</span><span class="p">);</span>  
        <span class="kt">float</span> <span class="n">vv</span><span class="o">=</span><span class="n">autoscale</span><span class="o">*</span><span class="n">scale</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ori</span><span class="p">);</span>  
        <span class="kt">float</span> <span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">col</span><span class="p">)</span><span class="o">+</span><span class="n">uu</span><span class="p">;</span>  
        <span class="kt">float</span> <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">)</span><span class="o">+</span><span class="n">vv</span><span class="p">;</span>  
        <span class="n">cvLine</span><span class="p">(</span> <span class="n">image</span><span class="p">,</span> <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">col</span><span class="p">),(</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">)),</span>   
            <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">y</span><span class="p">),</span> <span class="n">CV_RGB</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>  
            <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  
        <span class="c1">// Arrow head parameters  </span>
        <span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.33</span><span class="p">;</span> <span class="c1">// Size of arrow head relative to the length of the vector  </span>
        <span class="kt">float</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.33</span><span class="p">;</span>  <span class="c1">// Width of the base of the arrow head relative to the length  </span>

        <span class="kt">float</span> <span class="n">xx0</span><span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">col</span><span class="p">)</span><span class="o">+</span><span class="n">uu</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">uu</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">vv</span><span class="p">);</span>  
        <span class="kt">float</span> <span class="n">yy0</span><span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">)</span><span class="o">+</span><span class="n">vv</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">vv</span><span class="o">-</span><span class="n">beta</span><span class="o">*</span><span class="n">uu</span><span class="p">);</span>  
        <span class="kt">float</span> <span class="n">xx1</span><span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">col</span><span class="p">)</span><span class="o">+</span><span class="n">uu</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">uu</span><span class="o">-</span><span class="n">beta</span><span class="o">*</span><span class="n">vv</span><span class="p">);</span>  
        <span class="kt">float</span> <span class="n">yy1</span><span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">)</span><span class="o">+</span><span class="n">vv</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">vv</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">uu</span><span class="p">);</span>  
        <span class="n">cvLine</span><span class="p">(</span> <span class="n">image</span><span class="p">,</span> <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">xx0</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">yy0</span><span class="p">),</span>   
            <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">y</span><span class="p">),</span> <span class="n">CV_RGB</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>  
            <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  
        <span class="n">cvLine</span><span class="p">(</span> <span class="n">image</span><span class="p">,</span> <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">xx1</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">yy1</span><span class="p">),</span>   
            <span class="n">cvPoint</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">y</span><span class="p">),</span> <span class="n">CV_RGB</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>  
            <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  
    <span class="p">}</span>   
<span class="p">}</span>
</pre>
  </div>
  <h4>
   <a class="anchor" href="#sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%94%E6%AD%A5" name="user-content-sift%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%94%E6%AD%A5">
    <span class="octicon octicon-link">
    </span>
   </a>
   <strong>
    SIFT算法第五步
   </strong>
  </h4>
  <p>
   SIFT算法第五步：抽取各个特征点处的特征描述字，确定特征点的描述字。描述字是Patch网格内梯度方向的描述，旋转网格到主方向，插值得到网格处梯度值。
  </p>
  <p>
   一个特征点可以用2*2*8=32维的向量，也可以用4*4*8=128维的向量更精确的进行描述。
  </p>
  <div class="highlight highlight-c">
   <pre><span class="kt">void</span> <span class="nf">ExtractFeatureDescriptors</span><span class="p">(</span><span class="kt">int</span> <span class="n">numoctaves</span><span class="p">,</span> <span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">GaussianPyr</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="c1">// The orientation histograms have 8 bins  </span>
    <span class="kt">float</span> <span class="n">orient_bin_spacing</span> <span class="o">=</span> <span class="n">PI</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">orient_angles</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="o">-</span><span class="n">PI</span><span class="p">,</span><span class="o">-</span><span class="n">PI</span><span class="o">+</span><span class="n">orient_bin_spacing</span><span class="p">,</span><span class="o">-</span><span class="n">PI</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="n">orient_bin_spacing</span><span class="p">,</span>  
        <span class="mf">0.0</span><span class="p">,</span> <span class="n">orient_bin_spacing</span><span class="p">,</span> <span class="n">PI</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span>  <span class="n">PI</span><span class="o">+</span><span class="n">orient_bin_spacing</span><span class="p">};</span>  
    <span class="c1">//产生描述字中心各点坐标  </span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">feat_grid</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">GridSpacing</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">,</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">feat_grid</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">=-</span><span class="mf">6.0</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="n">GridSpacing</span><span class="p">;</span>  
            <span class="n">feat_grid</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="mf">6.0</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">j</span><span class="o">*</span><span class="n">GridSpacing</span><span class="p">;</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="c1">//产生网格  </span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">feat_samples</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="mi">256</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">*</span><span class="n">GridSpacing</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">*</span><span class="n">GridSpacing</span><span class="p">;</span><span class="n">j</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">feat_samples</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">=-</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>  
            <span class="n">feat_samples</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">j</span><span class="p">;</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="kt">float</span> <span class="n">feat_window</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="p">;</span>  
    <span class="n">Keypoint</span> <span class="n">p</span> <span class="o">=</span> <span class="n">keyDescriptors</span><span class="p">;</span> <span class="c1">// p指向第一个结点  </span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c1">// 没到表尾  </span>
    <span class="p">{</span>  
        <span class="kt">float</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">octave</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">absolute_sigma</span><span class="p">;</span>  

        <span class="kt">float</span> <span class="n">sine</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ori</span><span class="p">);</span>  
        <span class="kt">float</span> <span class="n">cosine</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ori</span><span class="p">);</span>    
        <span class="c1">//计算中心点坐标旋转之后的位置  </span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">featcenter</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">GridSpacing</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="p">;</span><span class="n">j</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span>  
            <span class="p">{</span>  
                <span class="kt">float</span> <span class="n">x</span><span class="o">=</span><span class="n">feat_grid</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>  
                <span class="kt">float</span> <span class="n">y</span><span class="o">=</span><span class="n">feat_grid</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  
                <span class="n">featcenter</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">cosine</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sx</span><span class="p">);</span>  
                <span class="n">featcenter</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">GridSpacing</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="o">-</span><span class="n">sine</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">cosine</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sy</span><span class="p">);</span>  
            <span class="p">}</span>  
        <span class="p">}</span>  
        <span class="c1">// calculate sample window coordinates (rotated along keypoint)  </span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">feat</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="mi">256</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">*</span><span class="n">GridSpacing</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="kt">float</span> <span class="n">x</span><span class="o">=</span><span class="n">feat_samples</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
            <span class="kt">float</span> <span class="n">y</span><span class="o">=</span><span class="n">feat_samples</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  
            <span class="n">feat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">cosine</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sx</span><span class="p">);</span>  
            <span class="n">feat</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="o">-</span><span class="n">sine</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">cosine</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sy</span><span class="p">);</span>  
        <span class="p">}</span>  
        <span class="c1">//Initialize the feature descriptor.  </span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">feat_desc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="mi">128</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">feat_desc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>  
            <span class="c1">// printf("%f  ",feat_desc[i]);    </span>
        <span class="p">}</span>  
        <span class="c1">//printf("/n");  </span>
        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">512</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">,</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="kt">float</span> <span class="n">x_sample</span> <span class="o">=</span> <span class="n">feat</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
            <span class="kt">float</span> <span class="n">y_sample</span> <span class="o">=</span> <span class="n">feat</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  
            <span class="c1">// Interpolate the gradient at the sample position  </span>
            <span class="cm">/* </span>
<span class="cm">            0   1   0 </span>
<span class="cm">            1   *   1 </span>
<span class="cm">            0   1   0   具体插值策略如图示 </span>
<span class="cm">            */</span>  
            <span class="kt">float</span> <span class="n">sample12</span><span class="o">=</span><span class="n">getPixelBI</span><span class="p">(((</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">octave</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]).</span><span class="n">Level</span><span class="p">,</span> <span class="n">x_sample</span><span class="p">,</span> <span class="n">y_sample</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  
            <span class="kt">float</span> <span class="n">sample21</span><span class="o">=</span><span class="n">getPixelBI</span><span class="p">(((</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">octave</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]).</span><span class="n">Level</span><span class="p">,</span> <span class="n">x_sample</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_sample</span><span class="p">);</span>   
            <span class="kt">float</span> <span class="n">sample22</span><span class="o">=</span><span class="n">getPixelBI</span><span class="p">(((</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">octave</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]).</span><span class="n">Level</span><span class="p">,</span> <span class="n">x_sample</span><span class="p">,</span> <span class="n">y_sample</span><span class="p">);</span>   
            <span class="kt">float</span> <span class="n">sample23</span><span class="o">=</span><span class="n">getPixelBI</span><span class="p">(((</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">octave</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]).</span><span class="n">Level</span><span class="p">,</span> <span class="n">x_sample</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_sample</span><span class="p">);</span>   
            <span class="kt">float</span> <span class="n">sample32</span><span class="o">=</span><span class="n">getPixelBI</span><span class="p">(((</span><span class="n">GaussianPyr</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">octave</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]).</span><span class="n">Level</span><span class="p">,</span> <span class="n">x_sample</span><span class="p">,</span> <span class="n">y_sample</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>   
            <span class="c1">//float diff_x = 0.5*(sample23 - sample21);  </span>
            <span class="c1">//float diff_y = 0.5*(sample32 - sample12);  </span>
            <span class="kt">float</span> <span class="n">diff_x</span> <span class="o">=</span> <span class="n">sample23</span> <span class="o">-</span> <span class="n">sample21</span><span class="p">;</span>  
            <span class="kt">float</span> <span class="n">diff_y</span> <span class="o">=</span> <span class="n">sample32</span> <span class="o">-</span> <span class="n">sample12</span><span class="p">;</span>  
            <span class="kt">float</span> <span class="n">mag_sample</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span> <span class="n">diff_x</span><span class="o">*</span><span class="n">diff_x</span> <span class="o">+</span> <span class="n">diff_y</span><span class="o">*</span><span class="n">diff_y</span> <span class="p">);</span>  
            <span class="kt">float</span> <span class="n">grad_sample</span> <span class="o">=</span> <span class="n">atan</span><span class="p">(</span> <span class="n">diff_y</span> <span class="o">/</span> <span class="n">diff_x</span> <span class="p">);</span>  
            <span class="k">if</span><span class="p">(</span><span class="n">grad_sample</span> <span class="o">==</span> <span class="n">CV_PI</span><span class="p">)</span>  
                <span class="n">grad_sample</span> <span class="o">=</span> <span class="o">-</span><span class="n">CV_PI</span><span class="p">;</span>  
            <span class="c1">// Compute the weighting for the x and y dimensions.  </span>
            <span class="kt">float</span> <span class="o">*</span><span class="n">x_wght</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">GridSpacing</span> <span class="o">*</span> <span class="n">GridSpacing</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  
            <span class="kt">float</span> <span class="o">*</span><span class="n">y_wght</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">GridSpacing</span> <span class="o">*</span> <span class="n">GridSpacing</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  
            <span class="kt">float</span> <span class="o">*</span><span class="n">pos_wght</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="mi">8</span><span class="o">*</span><span class="n">GridSpacing</span> <span class="o">*</span> <span class="n">GridSpacing</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));;</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">m</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="o">++</span><span class="n">m</span><span class="p">,</span><span class="o">++</span><span class="n">m</span><span class="p">)</span>  
            <span class="p">{</span>  
                <span class="kt">float</span> <span class="n">x</span><span class="o">=</span><span class="n">featcenter</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>  
                <span class="kt">float</span> <span class="n">y</span><span class="o">=</span><span class="n">featcenter</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  
                <span class="n">x_wght</span><span class="p">[</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_sample</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">GridSpacing</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>  
                <span class="n">y_wght</span><span class="p">[</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_sample</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">GridSpacing</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>   

            <span class="p">}</span>  
            <span class="k">for</span> <span class="p">(</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">m</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">;</span><span class="o">++</span><span class="n">m</span><span class="p">)</span>  
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="o">++</span><span class="n">n</span><span class="p">)</span>  
                    <span class="n">pos_wght</span><span class="p">[</span><span class="n">m</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">x_wght</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">y_wght</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>  
            <span class="n">free</span><span class="p">(</span><span class="n">x_wght</span><span class="p">);</span>  
            <span class="n">free</span><span class="p">(</span><span class="n">y_wght</span><span class="p">);</span>  
            <span class="c1">//计算方向的加权，首先旋转梯度场到主方向，然后计算差异   </span>
            <span class="kt">float</span> <span class="n">diff</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="n">orient_wght</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>  
            <span class="k">for</span> <span class="p">(</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">m</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="o">++</span><span class="n">m</span><span class="p">)</span>  
            <span class="p">{</span>   
                <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">grad_sample</span><span class="o">-</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ori</span><span class="p">)</span><span class="o">-</span><span class="n">orient_angles</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span><span class="n">CV_PI</span><span class="p">;</span>  
                <span class="kt">float</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">CV_PI</span><span class="p">);</span>  
                <span class="n">angle</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">temp</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">CV_PI</span><span class="p">);</span>  
                <span class="n">diff</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">=</span> <span class="n">angle</span> <span class="o">-</span> <span class="n">CV_PI</span><span class="p">;</span>  
            <span class="p">}</span>  
            <span class="c1">// Compute the gaussian weighting.  </span>
            <span class="kt">float</span> <span class="n">x</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sx</span><span class="p">;</span>  
            <span class="kt">float</span> <span class="n">y</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sy</span><span class="p">;</span>  
            <span class="kt">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x_sample</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x_sample</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">y_sample</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y_sample</span><span class="o">-</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">feat_window</span><span class="o">*</span><span class="n">feat_window</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">CV_PI</span><span class="o">*</span><span class="n">feat_window</span><span class="o">*</span><span class="n">feat_window</span><span class="p">);</span>  

            <span class="k">for</span> <span class="p">(</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">m</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">;</span><span class="o">++</span><span class="n">m</span><span class="p">)</span>  
            <span class="p">{</span>  
                <span class="n">orient_wght</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">fabs</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">m</span><span class="o">%</span><span class="mi">8</span><span class="p">])</span><span class="o">/</span><span class="n">orient_bin_spacing</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span>  
                <span class="n">feat_desc</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">feat_desc</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">orient_wght</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">pos_wght</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">mag_sample</span><span class="p">;</span>  
            <span class="p">}</span>  
            <span class="n">free</span><span class="p">(</span><span class="n">pos_wght</span><span class="p">);</span>     
        <span class="p">}</span>  
        <span class="n">free</span><span class="p">(</span><span class="n">feat</span><span class="p">);</span>  
        <span class="n">free</span><span class="p">(</span><span class="n">featcenter</span><span class="p">);</span>  
        <span class="kt">float</span> <span class="n">norm</span><span class="o">=</span><span class="n">GetVecNorm</span><span class="p">(</span> <span class="n">feat_desc</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>  
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">m</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">;</span><span class="n">m</span><span class="o">++</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">feat_desc</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">/=</span><span class="n">norm</span><span class="p">;</span>  
            <span class="k">if</span> <span class="p">(</span><span class="n">feat_desc</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.2</span><span class="p">)</span>  
                <span class="n">feat_desc</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">=</span><span class="mf">0.2</span><span class="p">;</span>  
        <span class="p">}</span>  
        <span class="n">norm</span><span class="o">=</span><span class="n">GetVecNorm</span><span class="p">(</span> <span class="n">feat_desc</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">m</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">;</span><span class="n">m</span><span class="o">++</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">feat_desc</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">/=</span><span class="n">norm</span><span class="p">;</span>  
            <span class="n">printf</span><span class="p">(</span><span class="s">"%f  "</span><span class="p">,</span><span class="n">feat_desc</span><span class="p">[</span><span class="n">m</span><span class="p">]);</span>    
        <span class="p">}</span>  
        <span class="n">printf</span><span class="p">(</span><span class="s">"/n"</span><span class="p">);</span>  
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">descrip</span> <span class="o">=</span> <span class="n">feat_desc</span><span class="p">;</span>  
        <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="n">free</span><span class="p">(</span><span class="n">feat_grid</span><span class="p">);</span>  
    <span class="n">free</span><span class="p">(</span><span class="n">feat_samples</span><span class="p">);</span>  
<span class="p">}</span>  

<span class="c1">//为了显示图象金字塔，而作的图像水平拼接  </span>
<span class="n">CvMat</span><span class="o">*</span> <span class="nf">MosaicHorizen</span><span class="p">(</span> <span class="n">CvMat</span><span class="o">*</span> <span class="n">im1</span><span class="p">,</span> <span class="n">CvMat</span><span class="o">*</span> <span class="n">im2</span> <span class="p">)</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">;</span>  
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">mosaic</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span> <span class="n">max</span><span class="p">(</span><span class="n">im1</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span><span class="n">im2</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">),(</span><span class="n">im1</span><span class="o">-&gt;</span><span class="n">cols</span><span class="o">+</span><span class="n">im2</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">),</span><span class="n">CV_32FC1</span><span class="p">);</span>  
<span class="cp">#define Mosaic(ROW,COL) ((float*)(mosaic-&gt;data.fl + mosaic-&gt;step/sizeof(float)*(ROW)))[(COL)]  </span>
<span class="cp">#define Im11Mat(ROW,COL) ((float *)(im1-&gt;data.fl + im1-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
<span class="cp">#define Im22Mat(ROW,COL) ((float *)(im2-&gt;data.fl + im2-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="n">cvZero</span><span class="p">(</span><span class="n">mosaic</span><span class="p">);</span>  
    <span class="cm">/* Copy images into mosaic1. */</span>  
    <span class="k">for</span> <span class="p">(</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">im1</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">im1</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span>  
            <span class="n">Mosaic</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span><span class="o">=</span><span class="n">Im11Mat</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="p">;</span>  
    <span class="k">for</span> <span class="p">(</span>  <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">im2</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span>  
        <span class="k">for</span> <span class="p">(</span>  <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">im2</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span>  
            <span class="n">Mosaic</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="n">im1</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">)</span> <span class="p">)</span><span class="o">=</span> <span class="n">Im22Mat</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="p">;</span>  
    <span class="k">return</span> <span class="n">mosaic</span><span class="p">;</span>  
<span class="p">}</span>  

<span class="c1">//为了显示图象金字塔，而作的图像垂直拼接  </span>
<span class="n">CvMat</span><span class="o">*</span> <span class="nf">MosaicVertical</span><span class="p">(</span> <span class="n">CvMat</span><span class="o">*</span> <span class="n">im1</span><span class="p">,</span> <span class="n">CvMat</span><span class="o">*</span> <span class="n">im2</span> <span class="p">)</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">;</span>  
    <span class="n">CvMat</span> <span class="o">*</span><span class="n">mosaic</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">im1</span><span class="o">-&gt;</span><span class="n">rows</span><span class="o">+</span><span class="n">im2</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span><span class="n">max</span><span class="p">(</span><span class="n">im1</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span><span class="n">im2</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">),</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
<span class="cp">#define Mosaic(ROW,COL) ((float*)(mosaic-&gt;data.fl + mosaic-&gt;step/sizeof(float)*(ROW)))[(COL)]  </span>
<span class="cp">#define Im11Mat(ROW,COL) ((float *)(im1-&gt;data.fl + im1-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
<span class="cp">#define Im22Mat(ROW,COL) ((float *)(im2-&gt;data.fl + im2-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="n">cvZero</span><span class="p">(</span><span class="n">mosaic</span><span class="p">);</span>  

    <span class="cm">/* Copy images into mosaic1. */</span>  
    <span class="k">for</span> <span class="p">(</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">im1</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">im1</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span>  
            <span class="n">Mosaic</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span><span class="o">=</span> <span class="n">Im11Mat</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="p">;</span>  
    <span class="k">for</span> <span class="p">(</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">im2</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span>  
        <span class="k">for</span> <span class="p">(</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">im2</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span>  
            <span class="n">Mosaic</span><span class="p">((</span><span class="n">row</span><span class="o">+</span><span class="n">im1</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">),</span><span class="n">col</span><span class="p">)</span><span class="o">=</span><span class="n">Im22Mat</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="p">;</span>  

    <span class="k">return</span> <span class="n">mosaic</span><span class="p">;</span>  
<span class="p">}</span>
</pre>
  </div>
  <p>
   ok，为了版述清晰，再贴一下上文所述的主函数（注，上文已贴出，此是为了版述清晰，重复造轮）：
  </p>
  <div class="highlight highlight-c">
   <pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>  
<span class="p">{</span>  
    <span class="c1">//声明当前帧IplImage指针  </span>
    <span class="n">IplImage</span><span class="o">*</span> <span class="n">src</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   
    <span class="n">IplImage</span><span class="o">*</span> <span class="n">image1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   
    <span class="n">IplImage</span><span class="o">*</span> <span class="n">grey_im1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   
    <span class="n">IplImage</span><span class="o">*</span> <span class="n">DoubleSizeImage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  

    <span class="n">IplImage</span><span class="o">*</span> <span class="n">mosaic1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   
    <span class="n">IplImage</span><span class="o">*</span> <span class="n">mosaic2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   

    <span class="n">CvMat</span><span class="o">*</span> <span class="n">mosaicHorizen1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">mosaicHorizen2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">mosaicVertical1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  

    <span class="n">CvMat</span><span class="o">*</span> <span class="n">image1Mat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
    <span class="n">CvMat</span><span class="o">*</span> <span class="n">tempMat</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>  

    <span class="n">ImageOctaves</span> <span class="o">*</span><span class="n">Gaussianpyr</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">;</span>  

<span class="cp">#define Im1Mat(ROW,COL) ((float *)(image1Mat-&gt;data.fl + image1Mat-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>

    <span class="c1">//灰度图象像素的数据结构  </span>
<span class="cp">#define Im1B(ROW,COL) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*3]  </span>
<span class="cp">#define Im1G(ROW,COL) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*3+1]  </span>
<span class="cp">#define Im1R(ROW,COL) ((uchar*)(image1-&gt;imageData + image1-&gt;widthStep*(ROW)))[(COL)*3+2]  </span>

    <span class="n">storage</span> <span class="o">=</span> <span class="n">cvCreateMemStorage</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   

    <span class="c1">//读取图片  </span>
    <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">src</span> <span class="o">=</span> <span class="n">cvLoadImage</span><span class="p">(</span> <span class="s">"street1.jpg"</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>  <span class="c1">// test1.jpg einstein.pgm back1.bmp  </span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  

    <span class="c1">//为图像分配内存   </span>
    <span class="n">image1</span> <span class="o">=</span> <span class="n">cvCreateImage</span><span class="p">(</span><span class="n">cvSize</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">),</span>  <span class="n">IPL_DEPTH_8U</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>  
    <span class="n">grey_im1</span> <span class="o">=</span> <span class="n">cvCreateImage</span><span class="p">(</span><span class="n">cvSize</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">),</span>  <span class="n">IPL_DEPTH_8U</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  
    <span class="n">DoubleSizeImage</span> <span class="o">=</span> <span class="n">cvCreateImage</span><span class="p">(</span><span class="n">cvSize</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">)),</span>  <span class="n">IPL_DEPTH_8U</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>  

    <span class="c1">//为图像阵列分配内存，假设两幅图像的大小相同，tempMat跟随image1的大小  </span>
    <span class="n">image1Mat</span> <span class="o">=</span> <span class="n">cvCreateMat</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">CV_32FC1</span><span class="p">);</span>  
    <span class="c1">//转化成单通道图像再处理  </span>
    <span class="n">cvCvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">grey_im1</span><span class="p">,</span> <span class="n">CV_BGR2GRAY</span><span class="p">);</span>  
    <span class="c1">//转换进入Mat数据结构,图像操作使用的是浮点型操作  </span>
    <span class="n">cvConvert</span><span class="p">(</span><span class="n">grey_im1</span><span class="p">,</span> <span class="n">image1Mat</span><span class="p">);</span>  

    <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">cvGetTickCount</span><span class="p">();</span>  
    <span class="c1">//图像归一化  </span>
    <span class="n">cvConvertScale</span><span class="p">(</span> <span class="n">image1Mat</span><span class="p">,</span> <span class="n">image1Mat</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  

    <span class="kt">int</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">image1Mat</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">,</span> <span class="n">image1Mat</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">);</span>  
    <span class="n">numoctaves</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">log</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">//金字塔阶数  </span>
    <span class="n">numoctaves</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">numoctaves</span><span class="p">,</span> <span class="n">MAXOCTAVES</span><span class="p">);</span>  

    <span class="c1">//SIFT算法第一步，预滤波除噪声，建立金字塔底层  </span>
    <span class="n">tempMat</span> <span class="o">=</span> <span class="n">ScaleInitImage</span><span class="p">(</span><span class="n">image1Mat</span><span class="p">)</span> <span class="p">;</span>  
    <span class="c1">//SIFT算法第二步，建立Guassian金字塔和DOG金字塔  </span>
    <span class="n">Gaussianpyr</span> <span class="o">=</span> <span class="n">BuildGaussianOctaves</span><span class="p">(</span><span class="n">tempMat</span><span class="p">)</span> <span class="p">;</span>  

    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">cvGetTickCount</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">;</span>  
    <span class="n">printf</span><span class="p">(</span> <span class="s">"the time of build Gaussian pyramid and DOG pyramid is %.1f/n"</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="p">(</span><span class="n">cvGetTickFrequency</span><span class="p">()</span><span class="o">*</span><span class="mf">1000.</span><span class="p">)</span> <span class="p">);</span>  

<span class="cp">#define ImLevels(OCTAVE,LEVEL,ROW,COL) ((float *)(Gaussianpyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;data.fl + Gaussianpyr[(OCTAVE)].Octave[(LEVEL)].Level-&gt;step/sizeof(float) *(ROW)))[(COL)]  </span>
    <span class="c1">//显示高斯金字塔  </span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numoctaves</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="p">(</span><span class="n">Gaussianpyr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">Level</span><span class="p">,</span> <span class="p">(</span><span class="n">Gaussianpyr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">SCALESPEROCTAVE</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="n">mosaicHorizen1</span><span class="p">,</span> <span class="p">(</span><span class="n">Gaussianpyr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">NUMSIZE</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">halfSizeImage</span><span class="p">(</span><span class="n">mosaicHorizen1</span><span class="p">);</span>  
        <span class="p">}</span>  
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">mosaicHorizen2</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="p">(</span><span class="n">Gaussianpyr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">Level</span><span class="p">,</span> <span class="p">(</span><span class="n">Gaussianpyr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">SCALESPEROCTAVE</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen2</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="n">mosaicHorizen2</span><span class="p">,</span> <span class="p">(</span><span class="n">Gaussianpyr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">NUMSIZE</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen2</span><span class="o">=</span><span class="n">halfSizeImage</span><span class="p">(</span><span class="n">mosaicHorizen2</span><span class="p">);</span>  
            <span class="n">mosaicVertical1</span><span class="o">=</span><span class="n">MosaicVertical</span><span class="p">(</span> <span class="n">mosaicHorizen1</span><span class="p">,</span> <span class="n">mosaicHorizen2</span> <span class="p">);</span>  
        <span class="p">}</span>  
        <span class="k">else</span>  
        <span class="p">{</span>  
            <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="p">(</span><span class="n">Gaussianpyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">Level</span><span class="p">,</span> <span class="p">(</span><span class="n">Gaussianpyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">SCALESPEROCTAVE</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="n">mosaicHorizen1</span><span class="p">,</span> <span class="p">(</span><span class="n">Gaussianpyr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">NUMSIZE</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">halfSizeImage</span><span class="p">(</span><span class="n">mosaicHorizen1</span><span class="p">);</span>  
            <span class="n">mosaicVertical1</span><span class="o">=</span><span class="n">MosaicVertical</span><span class="p">(</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="n">mosaicHorizen1</span> <span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="n">mosaic1</span> <span class="o">=</span> <span class="n">cvCreateImage</span><span class="p">(</span><span class="n">cvSize</span><span class="p">(</span><span class="n">mosaicVertical1</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">mosaicVertical1</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">),</span>  <span class="n">IPL_DEPTH_8U</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  
    <span class="n">cvConvertScale</span><span class="p">(</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="mf">255.0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  
    <span class="n">cvConvertScaleAbs</span><span class="p">(</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="n">mosaic1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  

    <span class="c1">//  cvSaveImage("GaussianPyramid of me.jpg",mosaic1);  </span>
    <span class="n">cvNamedWindow</span><span class="p">(</span><span class="s">"mosaic1"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  
    <span class="n">cvShowImage</span><span class="p">(</span><span class="s">"mosaic1"</span><span class="p">,</span> <span class="n">mosaic1</span><span class="p">);</span>  
    <span class="n">cvWaitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
    <span class="n">cvDestroyWindow</span><span class="p">(</span><span class="s">"mosaic1"</span><span class="p">);</span>  
    <span class="c1">//显示DOG金字塔  </span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numoctaves</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="p">(</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">Level</span><span class="p">,</span> <span class="p">(</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">SCALESPEROCTAVE</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="n">mosaicHorizen1</span><span class="p">,</span> <span class="p">(</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">NUMSIZE</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">halfSizeImage</span><span class="p">(</span><span class="n">mosaicHorizen1</span><span class="p">);</span>  
        <span class="p">}</span>  
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">mosaicHorizen2</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="p">(</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">Level</span><span class="p">,</span> <span class="p">(</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">SCALESPEROCTAVE</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen2</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="n">mosaicHorizen2</span><span class="p">,</span> <span class="p">(</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">NUMSIZE</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen2</span><span class="o">=</span><span class="n">halfSizeImage</span><span class="p">(</span><span class="n">mosaicHorizen2</span><span class="p">);</span>  
            <span class="n">mosaicVertical1</span><span class="o">=</span><span class="n">MosaicVertical</span><span class="p">(</span> <span class="n">mosaicHorizen1</span><span class="p">,</span> <span class="n">mosaicHorizen2</span> <span class="p">);</span>  
        <span class="p">}</span>  
        <span class="k">else</span>  
        <span class="p">{</span>  
            <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="p">(</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">Level</span><span class="p">,</span> <span class="p">(</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">SCALESPEROCTAVE</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">MosaicHorizen</span><span class="p">(</span> <span class="n">mosaicHorizen1</span><span class="p">,</span> <span class="p">(</span><span class="n">DOGoctaves</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Octave</span><span class="p">)[</span><span class="n">j</span><span class="p">].</span><span class="n">Level</span> <span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">NUMSIZE</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>  
                <span class="n">mosaicHorizen1</span><span class="o">=</span><span class="n">halfSizeImage</span><span class="p">(</span><span class="n">mosaicHorizen1</span><span class="p">);</span>  
            <span class="n">mosaicVertical1</span><span class="o">=</span><span class="n">MosaicVertical</span><span class="p">(</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="n">mosaicHorizen1</span> <span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="c1">//考虑到DOG金字塔各层图像都会有正负，所以，必须寻找最负的，以将所有图像抬高一个台阶去显示  </span>
    <span class="kt">double</span> <span class="n">min_val</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  
    <span class="kt">double</span> <span class="n">max_val</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  
    <span class="n">cvMinMaxLoc</span><span class="p">(</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min_val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_val</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span> <span class="n">min_val</span><span class="o">&lt;</span><span class="mf">0.0</span> <span class="p">)</span>  
        <span class="n">cvAddS</span><span class="p">(</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="n">cvScalarAll</span><span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">min_val</span> <span class="p">),</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>  
    <span class="n">mosaic2</span> <span class="o">=</span> <span class="n">cvCreateImage</span><span class="p">(</span><span class="n">cvSize</span><span class="p">(</span><span class="n">mosaicVertical1</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">mosaicVertical1</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">),</span>  <span class="n">IPL_DEPTH_8U</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  
    <span class="n">cvConvertScale</span><span class="p">(</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="mf">255.0</span><span class="o">/</span><span class="p">(</span><span class="n">max_val</span><span class="o">-</span><span class="n">min_val</span><span class="p">),</span> <span class="mi">0</span> <span class="p">);</span>  
    <span class="n">cvConvertScaleAbs</span><span class="p">(</span> <span class="n">mosaicVertical1</span><span class="p">,</span> <span class="n">mosaic2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>  

    <span class="c1">//  cvSaveImage("DOGPyramid of me.jpg",mosaic2);  </span>
    <span class="n">cvNamedWindow</span><span class="p">(</span><span class="s">"mosaic1"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  
    <span class="n">cvShowImage</span><span class="p">(</span><span class="s">"mosaic1"</span><span class="p">,</span> <span class="n">mosaic2</span><span class="p">);</span>  
    <span class="n">cvWaitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  

    <span class="c1">//SIFT算法第三步：特征点位置检测，最后确定特征点的位置  </span>
    <span class="kt">int</span> <span class="n">keycount</span><span class="o">=</span><span class="n">DetectKeypoint</span><span class="p">(</span><span class="n">numoctaves</span><span class="p">,</span> <span class="n">Gaussianpyr</span><span class="p">);</span>  
    <span class="n">printf</span><span class="p">(</span><span class="s">"the keypoints number are %d ;/n"</span><span class="p">,</span> <span class="n">keycount</span><span class="p">);</span>  
    <span class="n">cvCopy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">image1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>  
    <span class="n">DisplayKeypointLocation</span><span class="p">(</span> <span class="n">image1</span> <span class="p">,</span><span class="n">Gaussianpyr</span><span class="p">);</span>  

    <span class="n">cvPyrUp</span><span class="p">(</span> <span class="n">image1</span><span class="p">,</span> <span class="n">DoubleSizeImage</span><span class="p">,</span> <span class="n">CV_GAUSSIAN_5x5</span> <span class="p">);</span>  
    <span class="n">cvNamedWindow</span><span class="p">(</span><span class="s">"image1"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  
    <span class="n">cvShowImage</span><span class="p">(</span><span class="s">"image1"</span><span class="p">,</span> <span class="n">DoubleSizeImage</span><span class="p">);</span>  
    <span class="n">cvWaitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>    
    <span class="n">cvDestroyWindow</span><span class="p">(</span><span class="s">"image1"</span><span class="p">);</span>  

    <span class="c1">//SIFT算法第四步：计算高斯图像的梯度方向和幅值，计算各个特征点的主方向  </span>
    <span class="n">ComputeGrad_DirecandMag</span><span class="p">(</span><span class="n">numoctaves</span><span class="p">,</span> <span class="n">Gaussianpyr</span><span class="p">);</span>  
    <span class="n">AssignTheMainOrientation</span><span class="p">(</span> <span class="n">numoctaves</span><span class="p">,</span> <span class="n">Gaussianpyr</span><span class="p">,</span><span class="n">mag_pyr</span><span class="p">,</span><span class="n">grad_pyr</span><span class="p">);</span>  
    <span class="n">cvCopy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">image1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>  
    <span class="n">DisplayOrientation</span> <span class="p">(</span> <span class="n">image1</span><span class="p">,</span> <span class="n">Gaussianpyr</span><span class="p">);</span>  

    <span class="c1">//  cvPyrUp( image1, DoubleSizeImage, CV_GAUSSIAN_5x5 );  </span>
    <span class="n">cvNamedWindow</span><span class="p">(</span><span class="s">"image1"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>  
    <span class="c1">//  cvResizeWindow("image1", 2*(image1-&gt;width), 2*(image1-&gt;height) );  </span>
    <span class="n">cvShowImage</span><span class="p">(</span><span class="s">"image1"</span><span class="p">,</span> <span class="n">image1</span><span class="p">);</span>  
    <span class="n">cvWaitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  

    <span class="c1">//SIFT算法第五步：抽取各个特征点处的特征描述字  </span>
    <span class="n">ExtractFeatureDescriptors</span><span class="p">(</span> <span class="n">numoctaves</span><span class="p">,</span> <span class="n">Gaussianpyr</span><span class="p">);</span>  
    <span class="n">cvWaitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  

    <span class="c1">//销毁窗口  </span>
    <span class="n">cvDestroyWindow</span><span class="p">(</span><span class="s">"image1"</span><span class="p">);</span>  
    <span class="n">cvDestroyWindow</span><span class="p">(</span><span class="s">"mosaic1"</span><span class="p">);</span>  
    <span class="c1">//释放图像  </span>
    <span class="n">cvReleaseImage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image1</span><span class="p">);</span>  
    <span class="n">cvReleaseImage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grey_im1</span><span class="p">);</span>  
    <span class="n">cvReleaseImage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mosaic1</span><span class="p">);</span>  
    <span class="n">cvReleaseImage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mosaic2</span><span class="p">);</span>  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>
</pre>
  </div>
  <p>
   最后，再看一下，运行效果（图中美女为老乡+朋友，何姐08年照）：
  </p>
  <p>
   <a href="/ebook/images/10/10.1.3/10.1.3.1.jpg" target="_blank">
    <img alt="" src="/ebook/images/10/10.1.3/10.1.3.1.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   <a href="/ebook/images/10/10.1.3/10.1.3.2.jpg" target="_blank">
    <img alt="" src="/ebook/images/10/10.1.3/10.1.3.2.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   <a href="/ebook/images/10/10.1.3/10.1.3.3.jpg" target="_blank">
    <img alt="" src="/ebook/images/10/10.1.3/10.1.3.3.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   <a href="/ebook/images/10/10.1.3/10.1.3.4.jpg" target="_blank">
    <img alt="" src="/ebook/images/10/10.1.3/10.1.3.4.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   <a href="/ebook/images/10/10.1.3/10.1.3.5.jpg" target="_blank">
    <img alt="" src="/ebook/images/10/10.1.3/10.1.3.5.jpg" style="max-width:100%;"/>
   </a>
  </p>
  <p>
   完。
  </p>
  <p>
   <strong>
    updated
   </strong>
  </p>
  <p>
   有很多朋友都在本文评论下要求要本程序的完整源码包（注：本文代码未贴全，复制粘贴编译肯定诸多错误），但由于时隔太久，这份代码我自己也找不到了，不过，我可以提供一份sift + KD + BBF，且可以编译正确的代码供大家参考学习，有pudn帐号的朋友可以前去下载：
   <a>
    http://www.pudn.com/downloads340/sourcecode/graph/texture_mapping/detail1486667.html
   </a>
   （没有pudn账号的同学请加群：169056165，验证信息：sift，至群共享下载），然后用两幅不同的图片做了下匹配（当然，运行结果显示是不匹配的），效果还不错：
   <a href="http://weibo.com/1580904460/yDmzAEwcV#1348475194313">
    http://weibo.com/1580904460/yDmzAEwcV#1348475194313
   </a>
   ! July、二零一二年十月十一日。
  </p>
 </body>
</html>
		  </article>
		  
			<div id="nav">
				
					<a href="10.01.02.html">prev</a>
					|
				
				
					<a href="10.02.01.html">next</a>
				
				<span style="float: right"><a href="index.html">Back to home</a>
			</div>
		  
		</div>
	</div>
  </div>
  
  <div>&nbsp;</div>
  </div>
  <div style="text-align:center; margin-bottom: 30px">
	  Generated by <a href="https://github.com/marchtea/md_to_github_html">mdtogh</a>
  </div>
</body>
</html>